import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

import markdownItKatex from 'markdown-it-katex';
import { type DefaultTheme, defineConfig } from 'vitepress';

import sidebars from '../docs/sidebars';

const configFilePath = fileURLToPath(import.meta.url);
const configDir = path.dirname(configFilePath);
const rootDir = path.resolve(configDir, '..');
const docTitleCache = new Map<string, string | null>();

type MarkdownItLike = {
  utils: { escapeHtml: (value: string) => string };
  renderer: { rules: Record<string, unknown> };
  use: (plugin: unknown, ...args: unknown[]) => void;
  core: {
    ruler: {
      after: (
        afterName: string,
        ruleName: string,
        fn: (state: { tokens: MarkdownTokenLike[] }) => void,
      ) => void;
    };
  };
};

type MarkdownTokenLike = {
  info?: string;
  content?: string;
  type?: string;
  children?: MarkdownTokenLike[];
  attrs?: Array<[string, string]>;
};

function toPosixPath(p: string) {
  return p.replaceAll(path.sep, '/');
}

function readFrontmatterTitle(filePath: string): string | null {
  try {
    const raw = fs.readFileSync(filePath, 'utf8');
    if (!raw.startsWith('---')) {
      return null;
    }
    const end = raw.indexOf('\n---', 3);
    if (end < 0) {
      return null;
    }
    const fm = raw.slice(3, end).split('\n');
    for (const line of fm) {
      const m = line.match(/^\s*title\s*:\s*(.+?)\s*$/);
      if (m) {
        return m[1].replace(/^['"]|['"]$/g, '');
      }
    }
    return null;
  } catch {
    return null;
  }
}

function listDocsUnderDir(dirRelativeToRoot: string): DefaultTheme.SidebarItem[] {
  const absDir = path.resolve(rootDir, dirRelativeToRoot);
  if (!fs.existsSync(absDir)) {
    return [];
  }
  const files = fs
    .readdirSync(absDir)
    .filter((f) => f.endsWith('.md') || f.endsWith('.mdx'))
    .filter((f) => f.toLowerCase() !== 'readme.md')
    .sort((a, b) => a.localeCompare(b));

  return files.map((f) => {
    const abs = path.resolve(absDir, f);
    const title = readFrontmatterTitle(abs) ?? path.parse(f).name;
    const rel = toPosixPath(path.relative(rootDir, abs)).replace(/\.(md|mdx)$/, '');
    return { text: title, link: `/${rel}` };
  });
}

function splitIndexSidebarItem(items: DefaultTheme.SidebarItem[]) {
  const indexItem = items.find((it) => typeof it.link === 'string' && it.link.endsWith('/index'));
  if (!indexItem || typeof indexItem.link !== 'string') {
    return { indexLink: null as string | null, items };
  }
  const baseLink = `${indexItem.link.slice(0, -'/index'.length)}/`;
  const nonIndexItems = items.filter((it) => it !== indexItem);
  const overviewItem: DefaultTheme.SidebarItem = { text: '概览', link: baseLink };
  return { indexLink: baseLink, items: [overviewItem, ...nonIndexItems] };
}

function getDocTitleById(docId: string): string | null {
  const key = docId.replaceAll('\\', '/');
  if (docTitleCache.has(key)) {
    return docTitleCache.get(key) ?? null;
  }
  const abs = path.resolve(rootDir, 'docs', `${key}.md`);
  const indexAbs = path.resolve(rootDir, 'docs', key, 'index.md');
  const title = readFrontmatterTitle(abs) ?? readFrontmatterTitle(indexAbs);
  docTitleCache.set(key, title);
  return title;
}

type DocusaurusSidebarItem =
  | string
  | {
      type: 'category' | 'autogenerated';
      label?: string;
      items?: DocusaurusSidebarItem[];
      dirName?: string;
      collapsed?: boolean;
    };

function toVitePressSidebarItems(items: DocusaurusSidebarItem[]): DefaultTheme.SidebarItem[] {
  const out: DefaultTheme.SidebarItem[] = [];
  for (const it of items) {
    if (typeof it === 'string') {
      const title = getDocTitleById(it);
      out.push({ text: title ?? it.split('/').slice(-1)[0] ?? it, link: `/docs/${it}` });
      continue;
    }
    if (it.type === 'autogenerated' && it.dirName) {
      const dir = path.posix.join('docs', it.dirName);
      const listed = listDocsUnderDir(dir);
      const split = splitIndexSidebarItem(listed);
      out.push({
        text: it.label ?? it.dirName.split('/').slice(-1)[0] ?? it.dirName,
        link: split.indexLink ?? undefined,
        items: split.items,
        collapsed: true,
      });
      continue;
    }
    if (it.type === 'category') {
      const label = it.label ?? '未命名分组';
      const rawItems = it.items ?? [];
      const only = rawItems.length === 1 ? rawItems[0] : null;
      if (
        only &&
        typeof only !== 'string' &&
        only.type === 'autogenerated' &&
        only.dirName &&
        !only.label
      ) {
        const dir = path.posix.join('docs', only.dirName);
        const listed = listDocsUnderDir(dir);
        const split = splitIndexSidebarItem(listed);
        out.push({
          text: label,
          link: split.indexLink ?? undefined,
          items: split.items,
          collapsed: it.collapsed ?? false,
        });
      } else {
        const childItems = toVitePressSidebarItems(rawItems);
        out.push({ text: label, items: childItems, collapsed: it.collapsed ?? false });
      }
      continue;
    }
  }
  return out;
}

function buildSidebar(): DefaultTheme.Sidebar {
  const docsSidebar = (sidebars as unknown as { docs: DocusaurusSidebarItem[] }).docs ?? [];
  return {
    '/docs/': toVitePressSidebarItems(docsSidebar),
  };
}

function transformFlowToMermaid(src: string) {
  const lines = src
    .split('\n')
    .map((l) => l.trim())
    .filter(Boolean);
  const nodeDefs: string[] = [];
  const edgeDefs: string[] = [];
  for (const l of lines) {
    const m = l.match(/^(\w+)\s*=>\s*(\w+)\s*:\s*(.+)$/);
    if (m) {
      const id = m[1];
      const type = m[2].toLowerCase();
      const label = m[3];
      if (type === 'start' || type === 'end') {
        nodeDefs.push(`${id}([${label}])`);
      } else if (type === 'condition') {
        nodeDefs.push(`${id}{${label}}`);
      } else {
        nodeDefs.push(`${id}[${label}]`);
      }
      continue;
    }
    if (l.includes('->')) {
      const parts = l
        .split('->')
        .map((p) => p.trim())
        .filter(Boolean);
      const parse = (t: string) => {
        const mm = t.match(/^([A-Za-z0-9_]+)(?:\(([^)]+)\))?$/);
        return { id: mm ? mm[1] : t, label: mm && mm[2] ? mm[2] : null };
      };
      for (let i = 0; i < parts.length - 1; i++) {
        const a = parse(parts[i]);
        const b = parse(parts[i + 1]);
        const lbl = a.label ? `|${a.label}|` : '';
        edgeDefs.push(`${a.id} -->${lbl} ${b.id}`);
      }
    }
  }
  return `flowchart TD\n${nodeDefs.join('\n')}\n${edgeDefs.join('\n')}`;
}

function transformSeqToMermaid(src: string) {
  const body = src.trim();
  return `sequenceDiagram\n${body}`;
}

type FenceRule = (
  tokens: MarkdownTokenLike[],
  idx: number,
  options: unknown,
  env: unknown,
  self: unknown,
) => string;

function createFenceRenderer(md: MarkdownItLike): FenceRule {
  return (
    tokens: MarkdownTokenLike[],
    idx: number,
    _options: unknown,
    _env: unknown,
    _self: unknown,
  ): string => {
    const token = tokens[idx];
    const info = typeof token.info === 'string' ? token.info : '';
    const [lang = '', ...rest] = info.split(/\s+/);
    const meta = rest.join(' ').trim();
    const content = typeof token.content === 'string' ? token.content : '';
    const encoded = Buffer.from(content, 'utf8').toString('base64');
    if (lang === 'mermaid') {
      return `<InkMermaidBlock code-base64="${encoded}"></InkMermaidBlock>`;
    }
    if (lang === 'flow') {
      const m = Buffer.from(transformFlowToMermaid(content), 'utf8').toString('base64');
      return `<InkMermaidBlock code-base64="${m}"></InkMermaidBlock>`;
    }
    if (lang === 'seq') {
      const m = Buffer.from(transformSeqToMermaid(content), 'utf8').toString('base64');
      return `<InkMermaidBlock code-base64="${m}"></InkMermaidBlock>`;
    }
    return `<InkCodeBlock code-base64="${encoded}" lang="${md.utils.escapeHtml(
      lang,
    )}" meta="${md.utils.escapeHtml(meta)}"></InkCodeBlock>`;
  };
}

type RenderTokenSelf = {
  renderToken(tokens: MarkdownTokenLike[], idx: number, options: unknown): string;
};

type CodeInlineRule = (
  tokens: MarkdownTokenLike[],
  idx: number,
  options: unknown,
  env: unknown,
  self: unknown,
) => string;

function escapeVueMustacheInCodeInline(md: MarkdownItLike) {
  const existing = md.renderer.rules.code_inline as CodeInlineRule | undefined;
  const fallback: CodeInlineRule =
    existing ??
    ((tokens, idx, options, _env, self) =>
      (self as RenderTokenSelf).renderToken(tokens, idx, options));

  md.renderer.rules.code_inline = ((
    tokens: MarkdownTokenLike[],
    idx: number,
    options: unknown,
    env: unknown,
    self: unknown,
  ): string => {
    const token = tokens[idx];
    if (!token || typeof token.content !== 'string') {
      return fallback(tokens, idx, options, env, self);
    }
    const escaped = token.content.replaceAll('{{', '&#123;&#123;').replaceAll('}}', '&#125;&#125;');
    return `<code>${md.utils.escapeHtml(escaped)}</code>`;
  }) satisfies CodeInlineRule;
}

function enableTaskList(md: MarkdownItLike): void {
  const parseMarker = (content: string): { checked: boolean; markerLength: number } | null => {
    const m = content.match(/^\[(?<state>[ xX])\]\s+/);
    if (!m?.groups) {
      return null;
    }
    const checked = m.groups.state.toLowerCase() === 'x';
    return { checked, markerLength: m[0].length };
  };

  const ensureClass = (token: MarkdownTokenLike, className: string): void => {
    const attrs = (token.attrs ??= []);
    const existing = attrs.find((it) => it[0] === 'class');
    if (!existing) {
      attrs.push(['class', className]);
      return;
    }
    const parts = new Set(existing[1].split(/\s+/).filter(Boolean));
    parts.add(className);
    existing[1] = Array.from(parts).join(' ');
  };

  const injectCheckboxToInline = (inline: MarkdownTokenLike, checked: boolean, cut: number) => {
    const children = inline.children ?? [];
    const first = children[0];
    if (!first || typeof first.content !== 'string') {
      return;
    }
    first.content = first.content.slice(cut);
    inline.children = [
      {
        type: 'html_inline',
        content: `<input type="checkbox" disabled${checked ? ' checked' : ''}> `,
      },
      ...children,
    ];
  };

  md.core.ruler.after('inline', 'inkwell-task-list', (state) => {
    const tokens = state.tokens;
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      if (t.type !== 'list_item_open') {
        continue;
      }
      let inline: MarkdownTokenLike | null = null;
      for (let j = i + 1; j < tokens.length; j++) {
        const tt = tokens[j];
        if (tt.type === 'list_item_close') {
          break;
        }
        if (tt.type === 'inline' && Array.isArray(tt.children) && tt.children.length > 0) {
          inline = tt;
          break;
        }
      }
      if (!inline || !Array.isArray(inline.children) || inline.children.length === 0) {
        continue;
      }
      const first = inline.children[0];
      if (typeof first.content !== 'string') {
        continue;
      }
      const marker = parseMarker(first.content);
      if (!marker) {
        continue;
      }
      ensureClass(t, 'task-list-item');
      injectCheckboxToInline(inline, marker.checked, marker.markerLength);
    }
  });
}

export default defineConfig({
  title: 'Inkwell 文档',
  description: '基于 Canvas 的高性能 UI 系统，友好的 JSX 体验',
  lang: 'zh-CN',
  cleanUrls: true,
  srcExclude: ['**/README.md', 'src/**/*.md'],
  head: [
    ['link', { rel: 'icon', href: '/favicon.ico' }],
    [
      'script',
      {},
      `(()=>{try{var p=localStorage.getItem('ink-theme-preset');if(p==='antd'||p==='material'||p==='glass'||p==='vitepress'){document.documentElement.setAttribute('data-ink-preset',p);}}catch(e){}})();`,
    ],
    [
      'link',
      {
        rel: 'stylesheet',
        href: 'https://unpkg.com/katex@0.16.9/dist/katex.min.css',
        type: 'text/css',
      },
    ],
  ],
  themeConfig: {
    nav: [
      { text: '指引', link: '/docs/basic/intro' },
      { text: 'Playground', link: '/docs/demo/' },
      { text: 'GitHub', link: 'https://github.com/edeink/inkwell' },
      { text: '社区', link: 'https://github.com/edeink/inkwell/issues' },
    ],
    sidebar: buildSidebar(),
    outline: { level: [2, 3] },
    search: { provider: 'local' },
    footer: {
      message: `Copyright © ${new Date().getFullYear()} Inkwell`,
    },
  },
  markdown: {
    config(md: unknown) {
      const api = md as MarkdownItLike;
      api.use(markdownItKatex);
      escapeVueMustacheInCodeInline(api);
      enableTaskList(api);
      api.renderer.rules.fence = createFenceRenderer(api);
    },
  },
  transformHtml: (code, id, { content, pageData }) => {
    // Remove modulepreload for large vendor chunks that are not needed immediately
    // Use non-greedy match to avoid removing multiple links at once if on same line
    return code.replace(
      /<link rel="modulepreload" href="[^"]*(vendor-babel|vendor-mermaid|vendor-echarts)[^"]*">/g,
      '',
    );
  },
  vite: {
    resolve: {
      alias: {
        '@': path.resolve(rootDir, 'src'),
        '@demo': path.resolve(rootDir, 'src/demo'),
        '@mindmap': path.resolve(rootDir, 'src/demo/mindmap'),
        '@spreadsheet': path.resolve(rootDir, 'src/demo/spreadsheet'),
        'wiki-app': path.resolve(rootDir, 'src/demo/wiki/app.tsx'),
      },
    },
    build: {
      rollupOptions: {
        output: {
          manualChunks(id) {
            if (id.includes('node_modules')) {
              if (
                id.includes('mermaid') ||
                id.includes('echarts') ||
                id.includes('zrender') ||
                id.includes('katex') ||
                id.includes('shiki')
              ) {
                return 'docs-tools';
              }
            }
          },
        },
      },
    },
    css: {
      preprocessorOptions: {
        less: {
          javascriptEnabled: true,
        },
      },
    },
  },
});
