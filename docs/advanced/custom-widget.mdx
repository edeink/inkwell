---
id: custom-widget
title: 自定义 Widget
sidebar_position: 2
---

# 自定义 Widget 指南

Inkwell 提供了两种主要的方式来创建自定义 Widget：**组合 (Composition)** 和 **自定义渲染 (Custom Rendering)**。

## 1. 组合方式 (`render` 方法)

这是最常用也是推荐的方式。通过组合已有的基础组件（如 `Container`, `Row`, `Text`）来构建新的 UI。这种方式类似于 React 的组件开发。

### 适用场景
- 通用 UI 组件封装（按钮、卡片、表单项）。
- 业务页面构建。
- 不涉及复杂图形绘制的场景。

### 实现方式
继承 `StatefulWidget` (或 `StatelessWidget`) 并实现 `render` 方法。

### 代码示例：Button 组件

参考 `src/test/components/counter-tab/button.tsx`：

```tsx
import { StatefulWidget, WidgetProps } from '@/core/base';
import { Container, Row, Text } from '@/core';
import { EventHandler } from '@/core/events';
import { TextAlign, TextAlignVertical } from '@/core/text';

interface ButtonProps extends WidgetProps {
  onClick?: EventHandler;
  label?: string;
}

export class Button extends StatefulWidget<ButtonProps> {
  render() {
    return (
      <Container
        key="btn"
        width={180}
        height={48}
        color={'#1677ff'}
        borderRadius={8}
        onClick={this.props.onClick}
      >
        <Row>
          <Text
            text={this.props.label || "点击"}
            fontSize={16}
            color="#ffffff"
            textAlign={TextAlign.Center}
            textAlignVertical={TextAlignVertical.Center}
          />
          {this.props.children}
        </Row>
      </Container>
    );
  }
}
```

### 优势
- **开发效率高**：利用现有组件快速搭建。
- 自动布局：无需手动计算尺寸和位置，依赖 Flex 布局系统。

---

## 2. 函数式组件 (Functional Component)

这是最轻量级的组件定义方式，适用于无状态的纯展示型组件封装。

### 适用场景
- 简单的 UI 片段复用。
- 只有 Props 没有 State 的组件。
- 拆分大型 `render` 函数。

### 实现方式
定义一个接收 `props` 并返回 JSX 的函数。

### 代码示例：Section 组件

```tsx
const Section = ({ title, children }: { title: string; children: any }) => (
  <Column spacing={12}>
    <Text text={title} fontSize={20} fontWeight="bold" />
    <Container padding={16} color="#FFFFFF">
      {children}
    </Container>
  </Column>
);

// 使用
<Section title="Hello">
  <Text text="World" />
</Section>
```

**注意**：函数式组件在编译阶段会被展开为它返回的 Widget 树，因此在运行时它不会作为独立的 Widget 存在于树中（类似于内联展开）。

---

## 3. 自定义渲染方式 (`paintSelf` 方法)

当你需要完全控制绘制逻辑，或者需要绘制标准组件无法实现的图形（如图表、仪表盘、自定义形状）时，使用此方式。

### 适用场景
- 图表库 (Charts)。
- 游戏画面。
- 复杂的几何图形。
- 需要极致性能的原子组件。

### 实现方式
继承 `Widget` 类，并重写 `performLayout` 和 `paintSelf` 方法。

### 代码示例：Circle 组件

```tsx
import { Widget, type WidgetProps, type BuildContext, type BoxConstraints, type Size } from '@/core/base';

interface CircleProps extends WidgetProps {
  radius: number;
  color: string;
}

export class Circle extends Widget<CircleProps> {
  constructor(props: CircleProps) {
    super(props);
  }

  // 1. 必须实现布局逻辑，告诉父组件自己多大
  protected performLayout(constraints: BoxConstraints): Size {
    const diameter = this.props.radius * 2;
    // 确保尺寸不超过父组件约束
    return {
      width: Math.min(diameter, constraints.maxWidth),
      height: Math.min(diameter, constraints.maxHeight),
    };
  }

  // 2. 实现绘制逻辑
  protected paintSelf(context: BuildContext): void {
    const { renderer } = context;
    const { width, height } = this.renderObject.size;
    const radius = Math.min(width, height) / 2;
    
    // 使用 Canvas2D 接口绘制
    renderer.drawCircle({
      x: width / 2, // 相对坐标中心
      y: height / 2,
      radius: radius,
      fill: this.props.color,
    });
  }
}
```

### 性能注意事项
- **paintSelf 调用频繁**：每一帧都可能调用，避免在 `paintSelf` 中创建对象或进行复杂计算。
- **坐标系**：`paintSelf` 中的坐标是相对于组件左上角的（局部坐标），`renderer` 会自动处理全局变换。

---

## 两种方式对比

| 特性 | 组合方式 (`render`) | 自定义渲染 (`paintSelf`) |
|------|-------------------|------------------------|
| **基类** | `StatefulWidget` / `StatelessWidget` | `Widget` |
| **核心方法** | `render()` | `performLayout()`, `paintSelf()` |
| **布局能力** | 依赖子组件的布局 | 需手动计算自身尺寸 (`BoxConstraints` -> `Size`) |
| **绘制能力** | 依赖子组件的绘制 | 直接操作 Canvas API (`renderer.draw*`) |
| **复杂度** | 低 | 高 |
| **灵活性** | 中 | 极高 |

## 与父组件交互的最佳实践

1.  **Props 传递**：通过构造函数和 `props` 传递配置。
2.  **事件回调**：支持标准的 `on*` 事件属性（如 `onClick`）。在自定义渲染组件中，只要组件占据了空间（Layout 正确），事件系统就能自动命中它。
3.  **状态提升**：尽量将状态管理放在父组件（StatefulWidget）中，通过 Props 控制子组件（StatelessWidget 或 Custom Widget）的表现。
