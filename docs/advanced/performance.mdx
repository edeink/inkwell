---
id: performance
title: 性能优化指南
sidebar_position: 5
description: InkWell 性能优化最佳实践与案例分析
---

# 性能优化指南

本文档旨在帮助开发者编写高性能的 InkWell 应用。通过遵循以下最佳实践，你可以显著提升应用的帧率和响应速度。

## 最佳实践与案例分析

### 案例 1：计数器重复渲染优化

在早期版本中，我们发现简单的计数器组件点击一次会触发多次 `render`。通过深入分析，我们总结了以下优化原则：

#### 1. 避免在 Layout 阶段触发副作用

**问题**：如果在 `layout()` 方法中执行了可能触发更新的逻辑（如 `computeNextChildrenData` 导致的 `render`），会导致布局阶段产生额外的渲染开销。

**解决方案**：确保 `layout` 阶段仅进行几何计算。数据的准备和子组件的构建应在 `build` 或 `update` 阶段完成。

#### 2. 优化 Widget 重建 (Rebuild) 策略

**问题**：默认的 `rebuild` 逻辑可能过于激进，即使状态未改变也继续向下遍历。

**解决方案**：
- **脏标记检查**：如果组件未标记为 `dirty`，应直接跳过重建。
- **状态比对**：在 `StatefulWidget` 中，利用 `didStateChange` 或类似机制比对新旧 State/Props。如果数据未变，返回 `false` 阻止更新传播。

```typescript
// 示例：纯组件优化
class MyButton extends StatefulWidget {
  // ...
  didStateChange(oldState: State, newState: State): boolean {
    // 仅依赖 Props，且 Props 浅比较相等时，不触发更新
    return !shallowEqual(this.props, this.prevProps);
  }
}
```

#### 3. 使用 `StatelessWidget` 减少开销

对于不维护内部状态的组件，优先使用 `StatelessWidget`。它们结构更轻量，且通常不需要复杂的生命周期管理。

### 案例 2：复杂列表的滚动优化

**场景**：在包含大量图片的列表中滚动时出现掉帧。

**分析**：
1. 每一帧都重新构建了所有列表项，产生大量临时对象。
2. 绘制指令过多，且包含耗时的图片解码。

**优化方案**：
1. **虚拟滚动 (Virtualization)**：虽然 InkWell 尚未内置虚拟列表，但建议自行实现仅渲染可视区域内 Item 的逻辑。
2. **RepaintBoundary**：为列表项或列表容器添加 `isRepaintBoundary = true`。这样滚动条的更新或某个 Item 的内部状态变化不会污染整个视图。

## 通用优化建议

### 1. 减少层级深度
Canvas 绘图指令随层级增加，扁平化的结构通常渲染更快。避免无意义的 `Container` 嵌套。

### 2. 合理使用 `RepaintBoundary`
InkWell 支持局部重绘机制。在以下场景中开启 `RepaintBoundary`：
- **独立动画**：如加载 Spinner、光标闪烁。
- **复杂绘制**：如复杂的图表或地图，一旦绘制完成很少变动。
- **滚动区域**：将滚动内容与固定头部/底部隔离。

### 3. 缓存复杂绘制
对于绘制代价高昂且不常变化的组件，可以将其绘制到离屏 Canvas (Offscreen Canvas) 并作为图片缓存。InkWell 的 `RepaintBoundary` 机制在底层也利用了类似原理。

### 4. 避免在 `paint` 中创建对象
`paint` 方法每一帧都可能被调用。避免在其中创建新的对象（如 `Paint`、`Path`、闭包等），应复用成员变量。

### 5. 使用 `const` 风格的组件构建
如果子组件树是静态的，尽量在父组件外部定义或使用 `useMemo` (如果是在 Hook 环境下) / 成员变量缓存，避免每次 `build` 都重新 `new Widget()`。
