---
id: performance
title: 性能优化指南
sidebar_position: 5
description: InkWell 性能基准与优化最佳实践
---

import { BenchmarkApp } from '@/benchmark/index.tsx'
import BrowserOnly from '@docusaurus/BrowserOnly'
import ErrorBoundary from '@docusaurus/ErrorBoundary'

# 性能优化指南

## 性能基准测试

<div>
  <p>本页提供 InkWell 与 DOM 的交互式性能基准对比，支持不同节点规模与场景（文本、Flex、绝对定位）。</p>
  <details>
    <summary>基准方法说明</summary>
    <ul>
      <li>统计指标：帧率（FPS）、主线程 Long Task 时长、内存占用。</li>
      <li>流程：每轮执行采集 → 构建 → 再采集，重复多次取平均。</li>
      <li>环境因素：浏览器优化与设备性能可能影响绝对数值，建议关注相对趋势。</li>
    </ul>
  </details>
  <BrowserOnly>
    {() => (
      <ErrorBoundary>
        <BenchmarkApp />
      </ErrorBoundary>
    )}
  </BrowserOnly>
</div>

## 最佳实践与案例分析

### 案例：计数器重复渲染优化

在早期版本中，我们发现简单的计数器组件点击一次会触发多次 `render`。通过深入分析，我们总结了以下优化原则：

#### 1. 避免在 Layout 阶段触发副作用

**问题**：如果在 `layout()` 方法中执行了可能触发更新的逻辑（如 `computeNextChildrenData` 导致的 `render`），会导致布局阶段产生额外的渲染开销。

**解决方案**：确保 `layout` 阶段仅进行几何计算。数据的准备和子组件的构建应在 `build` 或 `update` 阶段完成。

#### 2. 优化 Widget 重建 (Rebuild) 策略

**问题**：默认的 `rebuild` 逻辑可能过于激进，即使状态未改变也继续向下遍历。

**解决方案**：
- **脏标记检查**：如果组件未标记为 `dirty`，应直接跳过重建。
- **状态比对**：在 `StatefulWidget` 中，利用 `didStateChange` 或类似机制比对新旧 State/Props。如果数据未变，返回 `false` 阻止更新传播。

```typescript
// 示例：纯组件优化
class MyButton extends StatefulWidget {
  // ...
  didStateChange(oldState: State, newState: State): boolean {
    // 仅依赖 Props，且 Props 浅比较相等时，不触发更新
    return !shallowEqual(this.props, this.prevProps);
  }
}
```

#### 3. 使用 `StatelessWidget` 减少开销

对于不维护内部状态的组件，优先使用 `StatelessWidget`。它们结构更轻量，且通常不需要复杂的生命周期管理。

## 通用优化建议

1.  **减少层级深度**：Canvas 绘图指令随层级增加，扁平化的结构通常渲染更快。
2.  **合理使用 `RepaintBoundary`**：虽然 Inkwell 暂未完全实现类似 Flutter 的 `RepaintBoundary`，但在设计时应注意隔离频繁变化的区域（如光标、动画元素）与静态背景。
3.  **缓存复杂绘制**：对于绘制代价高昂且不常变化的组件，可以将其绘制到离屏 Canvas (Offscreen Canvas) 并作为图片缓存。
