var n=Object.defineProperty;var r=(d,e)=>n(d,"name",{value:e,configurable:!0});import{$ as s,a5 as i,S as c,V as g,ag as o,a6 as t}from"./chunks/plugin-vue_export-helper.hykleeSY.js";const k=JSON.parse('{"title":"更新机制","description":"","frontmatter":{"id":"update-mechanism","title":"更新机制","sidebar_position":2},"headers":[],"relativePath":"docs/core/update-mechanism.md","filePath":"docs/core/update-mechanism.md"}'),u={name:"docs/core/update-mechanism.md"};function h(d,e,p,m,_,b){const a=i("InkCodeBlock"),l=i("InkMermaidBlock");return g(),c("div",null,[e[0]||(e[0]=o('<h1 id="更新机制" tabindex="-1">更新机制 <a class="header-anchor" href="#更新机制" aria-label="Permalink to &quot;更新机制&quot;">​</a></h1><p>本文档详细解析 Inkwell 框架的组件更新机制，并结合近期的核心更新说明如何优化渲染性能。</p><h2 id="_1-更新触发机制" tabindex="-1">1. 更新触发机制 <a class="header-anchor" href="#_1-更新触发机制" aria-label="Permalink to &quot;1. 更新触发机制&quot;">​</a></h2><p>组件更新主要由 <code>Props</code> 变化或 <code>State</code> 变化触发。</p><h3 id="_1-1-state-变化" tabindex="-1">1.1 State 变化 <a class="header-anchor" href="#_1-1-state-变化" aria-label="Permalink to &quot;1.1 State 变化&quot;">​</a></h3><p>当 <code>StatefulWidget</code> 调用 <code>setState</code> 时，会触发以下流程：</p><ol><li><strong>合并状态</strong>: 新状态合并入当前状态。</li><li><strong>标记脏节点</strong>: 调用 <code>markDirty()</code>，将当前组件加入全局 <code>Runtime</code> 的脏节点列表 (<code>dirtyWidgets</code>)。</li><li><strong>调度更新</strong>: <code>Runtime</code> 请求下一帧动画帧 (<code>requestAnimationFrame</code>)。</li><li><strong>批量刷新</strong>: 在下一帧开始时，<code>Runtime</code> 执行更新消费（内部会循环调用 <code>rebuild()</code> 并刷新 Layout/Paint）。</li></ol><h3 id="_1-2-props-变化" tabindex="-1">1.2 Props 变化 <a class="header-anchor" href="#_1-2-props-变化" aria-label="Permalink to &quot;1.2 Props 变化&quot;">​</a></h3><p>Props 变化通常来自两类来源：</p><ol><li><strong>外部重新渲染</strong>：再次调用 <code>runtime.render(...)</code> 传入新的 JSX（或模板函数），Runtime 会重新编译为 <code>ComponentData</code> 并更新根节点（可能复用根节点）。</li><li><strong>树内重建传播</strong>：某个节点被标记为脏后，Runtime 在 <code>rebuild()</code> 中会对该节点执行子树更新，过程中会触发子节点的 <code>createElement(...)</code>，从而把新的 Props/childrenData 下发到子节点。</li></ol><p>Props 的落地入口是 <code>Widget.createElement(...)</code>：框架在此对比新旧数据，必要时触发 <code>didUpdateWidget(oldProps)</code>，并在子节点层面执行“复用/增删/更新”的结构调整。</p><h2 id="_2-核心更新-api-详解" tabindex="-1">2. 核心更新 API 详解 <a class="header-anchor" href="#_2-核心更新-api-详解" aria-label="Permalink to &quot;2. 核心更新 API 详解&quot;">​</a></h2><p>以下是更新链路中最关键的几组 API。</p><h3 id="_2-1-markdirty" tabindex="-1">2.1 markDirty() <a class="header-anchor" href="#_2-1-markdirty" aria-label="Permalink to &quot;2.1 markDirty()&quot;">​</a></h3><p>标记当前组件为&quot;脏&quot;状态，请求重新构建。</p><ul><li><strong>API</strong>: <code>markDirty(): void</code></li><li><strong>触发</strong>: 通常由 <code>setState</code> 内部自动调用；仅在直接继承 <code>Widget</code> 等低层组件中手动调用。</li><li><strong>机制</strong>: <ol><li>将 <code>_dirty</code> 标志置为 <code>true</code>。</li><li>调用 <code>runtime.scheduleUpdate(this)</code> 将自身加入调度队列。</li><li><strong>关键联动</strong>: 自动调用 <code>markNeedsLayout()</code>，因为重建通常意味着布局可能改变。</li></ol></li></ul>',16)),t(a,{"code-base64":"Ly8g56S65L6L77yaU3RhdGVmdWxXaWRnZXQg5L2/55SoIHNldFN0YXRlIOinpuWPkeabtOaWsO+8iOWGhemDqOS8muiwg+eUqCBtYXJrRGlydHnvvIkKY2xhc3MgSW50ZXJhY3RpdmVCb3ggZXh0ZW5kcyBTdGF0ZWZ1bFdpZGdldDxXaWRnZXRQcm9wcywgeyBoaWdobGlnaHQ6IGJvb2xlYW4gfT4gewogIHN0YXRlID0geyBoaWdobGlnaHQ6IGZhbHNlIH07CgogIG9uSG92ZXIoKSB7CiAgICB0aGlzLnNldFN0YXRlKHsgaGlnaGxpZ2h0OiB0cnVlIH0pOwogIH0KfQo=",lang:"typescript",meta:""}),e[1]||(e[1]=o('<h3 id="_2-2-markneedslayout" tabindex="-1">2.2 markNeedsLayout() <a class="header-anchor" href="#_2-2-markneedslayout" aria-label="Permalink to &quot;2.2 markNeedsLayout()&quot;">​</a></h3><p>标记当前组件布局失效。</p><ul><li><strong>API</strong>: <code>markNeedsLayout(): void</code></li><li><strong>触发</strong>: 修改了影响尺寸或位置的属性（如 <code>width</code>, <code>flex</code>）。</li><li><strong>机制 (Relayout Boundary)</strong>: <ul><li>框架会向上查找最近的 <strong>重布局边界 (Relayout Boundary)</strong>。</li><li>如果组件自身大小由父级紧约束决定（如 <code>FixedSize</code>），它本身就是边界。</li><li><strong>优化</strong>: 只有边界内的子树会重新布局，边界外的父级不受影响。</li></ul></li></ul>',3)),t(a,{"code-base64":"Y2xhc3MgUmVzaXphYmxlQm94IGV4dGVuZHMgV2lkZ2V0IHsKICBzZXRTaXplKHcsIGgpIHsKICAgIHRoaXMuX3dpZHRoID0gdzsKICAgIHRoaXMuX2hlaWdodCA9IGg7CiAgICB0aGlzLm1hcmtOZWVkc0xheW91dCgpOyAvLyDku4Xop6blj5HluIPlsYDkuI7nu5jliLbvvIzot7Pov4flrZDmoJHph43lu7oKICB9Cn0K",lang:"typescript",meta:""}),e[2]||(e[2]=o('<h3 id="_2-3-markneedspaint" tabindex="-1">2.3 markNeedsPaint() <a class="header-anchor" href="#_2-3-markneedspaint" aria-label="Permalink to &quot;2.3 markNeedsPaint()&quot;">​</a></h3><p>标记当前组件需要重绘。</p><ul><li><strong>API</strong>: <code>markNeedsPaint(): void</code></li><li><strong>触发</strong>: 修改了仅影响外观不影响布局的属性（如 <code>color</code>, <code>opacity</code>）。</li><li><strong>机制</strong>: <ul><li>将 <code>_needsPaint</code> 置为 <code>true</code>。</li><li>向上递归调用父级的 <code>markNeedsPaint</code>，直到遇到 <strong>重绘边界 (Repaint Boundary)</strong>。</li><li><strong>PipelineOwner</strong>: 最终会调用 <code>owner.schedulePaintFor(boundaryNode)</code>，将边界节点加入待重绘列表。</li></ul></li></ul><h4 id="更新传播示意图" tabindex="-1">更新传播示意图 <a class="header-anchor" href="#更新传播示意图" aria-label="Permalink to &quot;更新传播示意图&quot;">​</a></h4>',4)),t(l,{"code-base64":"Z3JhcGggTFIKICAgIEFbQ2hpbGQgTm9kZV0gLS0gbWFya05lZWRzUGFpbnQgLS0+IEJ7aXNSZXBhaW50Qm91bmRhcnk/fQogICAgQiAtLSBObyAtLT4gQ1tQYXJlbnQgTm9kZV0KICAgIEMgLS0gbWFya05lZWRzUGFpbnQgLS0+IER7aXNSZXBhaW50Qm91bmRhcnk/fQogICAgQiAtLSBZZXMgLS0+IEVbUGlwZWxpbmVPd25lci5zY2hlZHVsZVBhaW50Rm9yXQogICAgRCAtLSBZZXMgLS0+IEUK"}),t(a,{"code-base64":"Y2xhc3MgQ29sb3JCb3ggZXh0ZW5kcyBXaWRnZXQgewogIHNldENvbG9yKGMpIHsKICAgIHRoaXMuY29sb3IgPSBjOwogICAgdGhpcy5tYXJrTmVlZHNQYWludCgpOyAvLyDmnoHpgJ/mm7TmlrDvvJrml6AgQnVpbGTvvIzml6AgTGF5b3V077yM5LuFIFBhaW50CiAgfQp9Cg==",lang:"typescript",meta:""}),e[3]||(e[3]=o('<h3 id="_2-4-isrepaintboundary" tabindex="-1">2.4 isRepaintBoundary <a class="header-anchor" href="#_2-4-isrepaintboundary" aria-label="Permalink to &quot;2.4 isRepaintBoundary&quot;">​</a></h3><p>控制重绘边界的核心属性。</p><ul><li><strong>类型</strong>: <code>boolean</code></li><li><strong>默认值</strong>: <code>false</code></li><li><strong>作用</strong>: 当设置为 <code>true</code> 时，该组件会拥有独立的离屏 Canvas (Layer)。 <ul><li><strong>隔离</strong>: 子组件重绘不影响父组件。</li><li><strong>缓存</strong>: 父组件重绘时，如果该组件未脏，直接合成其缓存的 Canvas，无需重绘子树。</li></ul></li></ul><h4 id="典型应用场景" tabindex="-1">典型应用场景 <a class="header-anchor" href="#典型应用场景" aria-label="Permalink to &quot;典型应用场景&quot;">​</a></h4><ol><li><strong>复杂子树</strong>: 如包含大量节点的图表、地图。</li><li><strong>频繁更新</strong>: 如秒表、动画光标。</li><li><strong>静态背景</strong>: 内容基本不变的背景层。</li></ol>',5)),t(a,{"code-base64":"Ly8g56S65L6L77ya5bCG56eS6KGo57uE5Lu26K6+5Li66YeN57uY6L6555WM77yM6YG/5YWN5q+P56eS6YeN57uY5pW05Liq6aG16Z2iCmNsYXNzIFN0b3B3YXRjaCBleHRlbmRzIFN0YXRlZnVsV2lkZ2V0IHsKICBjb25zdHJ1Y3Rvcihwcm9wcykgewogICAgc3VwZXIocHJvcHMpOwogICAgdGhpcy5pc1JlcGFpbnRCb3VuZGFyeSA9IHRydWU7IC8vIOW8gOWQr+mHjee7mOi+ueeVjAogIH0KICAvLyAuLi4KfQo=",lang:"typescript",meta:""}),e[4]||(e[4]=o('<h2 id="_3-性能对比" tabindex="-1">3. 性能对比 <a class="header-anchor" href="#_3-性能对比" aria-label="Permalink to &quot;3. 性能对比&quot;">​</a></h2><p>理解不同更新方式的开销对于优化应用至关重要。</p><table tabindex="0"><thead><tr><th>更新方式</th><th>涉及阶段</th><th>复杂度</th><th>推荐场景</th></tr></thead><tbody><tr><td><code>markDirty</code></td><td>Build -&gt; Layout -&gt; Paint</td><td>高 (O(N))</td><td>结构变化、增删节点</td></tr><tr><td><code>markNeedsLayout</code></td><td>Layout -&gt; Paint</td><td>中 (O(logN) ~ O(N))</td><td>尺寸变化、位置移动</td></tr><tr><td><code>markNeedsPaint</code></td><td>Paint</td><td>低 (O(1) ~ O(Subtree))</td><td>颜色变化、透明度变化</td></tr></tbody></table><blockquote><p><strong>性能提示</strong>:</p><ol><li>尽可能使用 <code>markNeedsPaint</code> 而非 <code>markDirty</code>。</li><li>合理使用 <code>isRepaintBoundary</code> 隔离频繁更新的区域。</li><li>在不需要改变大小时，尽量使用固定尺寸的组件作为 Relayout Boundary。</li></ol></blockquote><h2 id="_4-脏检查与调度" tabindex="-1">4. 脏检查与调度 <a class="header-anchor" href="#_4-脏检查与调度" aria-label="Permalink to &quot;4. 脏检查与调度&quot;">​</a></h2><h3 id="脏检查-dirty-checking" tabindex="-1">脏检查 (Dirty Checking) <a class="header-anchor" href="#脏检查-dirty-checking" aria-label="Permalink to &quot;脏检查 (Dirty Checking)&quot;">​</a></h3><p>Inkwell 的更新调度涉及三类集合/列表：</p><ol><li><strong>Runtime.dirtyWidgets</strong>：需要执行 <code>rebuild()</code> 的节点集合（由 <code>markDirty()</code> 或 <code>scheduleUpdate()</code> 进入）。</li><li><strong>PipelineOwner 的布局脏集合</strong>：需要重新布局的节点集合（由 <code>markNeedsLayout()</code> 调度到 Relayout Boundary）。</li><li><strong>PipelineOwner 的绘制脏集合</strong>：需要重绘的节点集合（由 <code>markNeedsPaint()</code> 调度到 Repaint Boundary 或相关边界节点）。</li></ol><h3 id="调度流程-pipeline" tabindex="-1">调度流程 (Pipeline) <a class="header-anchor" href="#调度流程-pipeline" aria-label="Permalink to &quot;调度流程 (Pipeline)&quot;">​</a></h3><p>一次 Tick 的典型顺序：</p><ol><li><strong>Flush Layout</strong>: 按深度 <strong>从小到大</strong> (浅 -&gt; 深) 处理脏布局节点。确保父节点先计算约束，传递给子节点。</li><li><strong>Flush Paint</strong>: 按深度 <strong>从大到小</strong> (深 -&gt; 浅) 处理脏绘制节点。确保子节点先更新 Layer，父节点合成时能取到最新内容。</li></ol>',11))])}r(h,"_sfc_render");const P=s(u,[["render",h]]);export{k as __pageData,P as default};
