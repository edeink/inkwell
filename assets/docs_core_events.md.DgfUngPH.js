import{_ as n,C as c,c as l,o as s,ai as a,G as r,j as t,a as o}from"./chunks/framework.Ckc8SVM3.js";const C=JSON.parse('{"title":"事件系统","description":"","frontmatter":{"id":"events","title":"事件系统","sidebar_position":3},"headers":[],"relativePath":"docs/core/events.md","filePath":"docs/core/events.md"}'),i={name:"docs/core/events.md"};function h(u,e,b,g,m,v){const d=c("InkCodeBlock");return s(),l("div",null,[e[0]||(e[0]=a('<h1 id="事件系统" tabindex="-1">事件系统 <a class="header-anchor" href="#事件系统" aria-label="Permalink to &quot;事件系统&quot;">​</a></h1><p>Inkwell 实现了一套参考 DOM 事件流的事件传播机制，支持从 Canvas 接收原生事件并将其分发到 Widget 树中的目标节点。</p><h2 id="事件类型分类" tabindex="-1">事件类型分类 <a class="header-anchor" href="#事件类型分类" aria-label="Permalink to &quot;事件类型分类&quot;">​</a></h2><p>Inkwell 支持多种交互事件，涵盖鼠标、触控和指针交互。</p><h3 id="_1-鼠标事件-mouse-events" tabindex="-1">1. 鼠标事件 (Mouse Events) <a class="header-anchor" href="#_1-鼠标事件-mouse-events" aria-label="Permalink to &quot;1. 鼠标事件 (Mouse Events)&quot;">​</a></h3><table tabindex="0"><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td><code>click</code></td><td>单击</td></tr><tr><td><code>dblclick</code></td><td>双击 (兼容 <code>doubleclick</code>)</td></tr><tr><td><code>contextmenu</code></td><td>右键菜单</td></tr><tr><td><code>mousedown</code> / <code>mouseup</code></td><td>按下 / 抬起</td></tr><tr><td><code>mousemove</code></td><td>移动</td></tr><tr><td><code>mouseenter</code> / <code>mouseleave</code></td><td>进入 / 离开 (不冒泡)</td></tr><tr><td><code>mouseover</code> / <code>mouseout</code></td><td>进入 / 离开 (冒泡)</td></tr><tr><td><code>wheel</code></td><td>滚轮滚动</td></tr></tbody></table><h3 id="_2-指针事件-pointer-events" tabindex="-1">2. 指针事件 (Pointer Events) <a class="header-anchor" href="#_2-指针事件-pointer-events" aria-label="Permalink to &quot;2. 指针事件 (Pointer Events)&quot;">​</a></h3><p>推荐使用 Pointer 事件以同时支持鼠标和触控。</p><table tabindex="0"><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td><code>pointerdown</code></td><td>指针按下</td></tr><tr><td><code>pointermove</code></td><td>指针移动</td></tr><tr><td><code>pointerup</code></td><td>指针抬起</td></tr><tr><td><code>pointerover</code> / <code>pointerout</code></td><td>指针进入 / 离开（冒泡）</td></tr><tr><td><code>pointerenter</code> / <code>pointerleave</code></td><td>指针进入 / 离开（不冒泡）</td></tr></tbody></table><h3 id="_3-触控事件-touch-events" tabindex="-1">3. 触控事件 (Touch Events) <a class="header-anchor" href="#_3-触控事件-touch-events" aria-label="Permalink to &quot;3. 触控事件 (Touch Events)&quot;">​</a></h3><table tabindex="0"><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td><code>touchstart</code></td><td>触摸开始</td></tr><tr><td><code>touchmove</code></td><td>触摸移动</td></tr><tr><td><code>touchend</code></td><td>触摸结束</td></tr><tr><td><code>touchcancel</code></td><td>触摸取消</td></tr></tbody></table><h3 id="_4-键盘事件-keyboard-events" tabindex="-1">4. 键盘事件 (Keyboard Events) <a class="header-anchor" href="#_4-键盘事件-keyboard-events" aria-label="Permalink to &quot;4. 键盘事件 (Keyboard Events)&quot;">​</a></h3><table tabindex="0"><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td><code>keydown</code></td><td>键按下</td></tr><tr><td><code>keyup</code></td><td>键抬起</td></tr><tr><td><code>keypress</code></td><td>字符输入</td></tr></tbody></table><blockquote><p><strong>注意</strong>：</p><ol><li>键盘事件通常分发给<strong>根节点 (Root Widget)</strong> 或当前的<strong>焦点节点</strong>（如果实现了焦点管理）。</li><li>键盘事件的接收依赖于 Canvas 的焦点状态。框架会为 Canvas 设置可聚焦能力（例如 <code>tabIndex=0</code>），但在某些场景下仍可能需要先点击一次画布区域才能激活快捷键。</li></ol></blockquote><h3 id="_5-焦点事件-focus-events" tabindex="-1">5. 焦点事件 (Focus Events) <a class="header-anchor" href="#_5-焦点事件-focus-events" aria-label="Permalink to &quot;5. 焦点事件 (Focus Events)&quot;">​</a></h3><table tabindex="0"><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td><code>focus</code></td><td>获得焦点</td></tr><tr><td><code>blur</code></td><td>失去焦点</td></tr></tbody></table><h2 id="事件传播机制" tabindex="-1">事件传播机制 <a class="header-anchor" href="#事件传播机制" aria-label="Permalink to &quot;事件传播机制&quot;">​</a></h2><p>事件传播分为三个阶段，与 DOM 事件流一致：</p><ol><li><strong>捕获阶段 (Capture Phase)</strong>：事件从根节点 (Root) 向下传播到目标节点 (Target)。</li><li><strong>目标阶段 (Target Phase)</strong>：事件到达目标节点。</li><li><strong>冒泡阶段 (Bubble Phase)</strong>：事件从目标节点向上回传到根节点。</li></ol><h3 id="绑定方式" tabindex="-1">绑定方式 <a class="header-anchor" href="#绑定方式" aria-label="Permalink to &quot;绑定方式&quot;">​</a></h3><p>在 JSX 中，通过 <code>on[EventName]</code> 绑定冒泡阶段事件，通过 <code>on[EventName]Capture</code> 绑定捕获阶段事件。</p>',21)),r(d,{"code-base64":"Y2xhc3MgTXlCdXR0b24gZXh0ZW5kcyBTdGF0ZWZ1bFdpZGdldCB7CiAgcmVuZGVyKCkgewogICAgcmV0dXJuICgKICAgICAgPENvbnRhaW5lcgogICAgICAgIC8vIOWGkuazoemYtuauteinpuWPkQogICAgICAgIG9uQ2xpY2s9eyhlKSA9PiBjb25zb2xlLmxvZygn5oyJ6ZKu54K55Ye7JywgZSl9CiAgICAgICAgLy8g5o2V6I636Zi25q616Kem5Y+RCiAgICAgICAgb25DbGlja0NhcHR1cmU9eyhlKSA9PiBjb25zb2xlLmxvZygn5o2V6I636Zi25q61JywgZSl9CiAgICAgID4KICAgICAgICA8VGV4dCB0ZXh0PSJDbGljayBNZSIgLz4KICAgICAgPC9Db250YWluZXI+CiAgICApOwogIH0KfQo=",lang:"tsx",meta:""}),e[1]||(e[1]=t("h3",{id:"阻止传播",tabindex:"-1"},[o("阻止传播 "),t("a",{class:"header-anchor",href:"#阻止传播","aria-label":'Permalink to "阻止传播"'},"​")],-1)),e[2]||(e[2]=t("p",null,[o("在事件处理函数中调用 "),t("code",null,"e.stopPropagation()"),o(" 可阻止事件继续传播（包括捕获和冒泡的后续节点）。 此外，处理器返回 "),t("code",null,"false"),o(" 也会终止后续传播。")],-1)),r(d,{"code-base64":"Y29uc3QgaGFuZGxlRXZlbnQgPSAoZTogSW5rd2VsbEV2ZW50KSA9PiB7CiAgY29uc29sZS5sb2coJ0hhbmRsZWQnKTsKICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyDniLbnu4Tku7blsIbkuI3kvJrmlLbliLDmraTkuovku7YKfTsK",lang:"typescript",meta:""}),e[3]||(e[3]=a('<h2 id="自定义事件开发规范" tabindex="-1">自定义事件开发规范 <a class="header-anchor" href="#自定义事件开发规范" aria-label="Permalink to &quot;自定义事件开发规范&quot;">​</a></h2><h3 id="_1-命中测试-hit-test" tabindex="-1">1. 命中测试 (Hit Test) <a class="header-anchor" href="#_1-命中测试-hit-test" aria-label="Permalink to &quot;1. 命中测试 (Hit Test)&quot;">​</a></h3><p>事件系统依赖 <code>Hit Test</code> 算法来确定事件的目标节点。</p><ul><li><strong>自定义 Widget</strong>：如果实现了 <code>paintSelf</code>，通常需要确保组件有明确的尺寸 (<code>performLayout</code>)。事件系统会根据 <code>renderObject</code> 的 <code>offset</code> 和 <code>size</code> 进行矩形碰撞检测。</li><li><strong>透明区域</strong>：默认情况下，透明区域也能响应点击，只要该点在组件的布局范围内。</li></ul><h3 id="_2-类方法处理" tabindex="-1">2. 类方法处理 <a class="header-anchor" href="#_2-类方法处理" aria-label="Permalink to &quot;2. 类方法处理&quot;">​</a></h3><p>除了 JSX 属性，组件类也可以直接定义方法来处理事件，这种方式在性能上略优（避免闭包创建）。</p>',6)),r(d,{"code-base64":"Y2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBXaWRnZXQgewogIC8vIOiHquWKqOe7keWumuWIsCBjbGljayDkuovku7YKICBvbkNsaWNrKGU6IElua3dlbGxFdmVudCkgewogICAgY29uc29sZS5sb2coJ+mAmui/h+exu+aWueazleaUtuWIsOeCueWHuycsIGUpOwogIH0KICAKICAvLyDoh6rliqjnu5HlrprliLAgY2FwdHVyZSDpmLbmrrUKICBvbkNsaWNrQ2FwdHVyZShlOiBJbmt3ZWxsRXZlbnQpIHsKICAgIGNvbnNvbGUubG9nKCfpgJrov4fnsbvmlrnms5XmlLbliLDmjZXojrfpmLbmrrXkuovku7YnLCBlKTsKICB9Cn0K",lang:"typescript",meta:""}),e[4]||(e[4]=a('<p>事件系统中涉及的常见字符串（事件类型、阶段、后缀等）集中定义在 [constants.ts](file:///Users/edeink/Documents/inkwell/src/core/events/constants.ts)，以保持一致性与可维护性。</p><h2 id="常见问题排查指南" tabindex="-1">常见问题排查指南 <a class="header-anchor" href="#常见问题排查指南" aria-label="Permalink to &quot;常见问题排查指南&quot;">​</a></h2><h3 id="q-为什么-onclick-不触发" tabindex="-1">Q: 为什么 <code>onClick</code> 不触发？ <a class="header-anchor" href="#q-为什么-onclick-不触发" aria-label="Permalink to &quot;Q: 为什么 `onClick` 不触发？&quot;">​</a></h3><ol><li><strong>检查尺寸</strong>：使用 DevTools 查看组件的 <code>width</code> 和 <code>height</code> 是否为 0。如果是 0，点击无法命中。</li><li><strong>检查层级 (z-index)</strong>：可能有其他透明组件覆盖在目标组件之上。</li><li><strong>检查 pointerEvent</strong>：确认组件或父组件没有设置 <code>pointerEvent: &#39;none&#39;</code>。</li></ol><h3 id="q-如何处理-canvas-之外的点击" tabindex="-1">Q: 如何处理 Canvas 之外的点击？ <a class="header-anchor" href="#q-如何处理-canvas-之外的点击" aria-label="Permalink to &quot;Q: 如何处理 Canvas 之外的点击？&quot;">​</a></h3><p>Inkwell 的事件系统仅托管 Canvas 内部的事件。如果需要处理 Canvas 外部（如整个 Window）的点击（例如点击空白处关闭弹窗），请使用浏览器原生的 <code>document.addEventListener</code>。</p><h3 id="q-mouseenter-和-mouseover-的区别" tabindex="-1">Q: <code>mouseenter</code> 和 <code>mouseover</code> 的区别？ <a class="header-anchor" href="#q-mouseenter-和-mouseover-的区别" aria-label="Permalink to &quot;Q: `mouseenter` 和 `mouseover` 的区别？&quot;">​</a></h3><ul><li><code>mouseover</code> 会冒泡。当鼠标移入子组件时，父组件也会收到 <code>mouseover</code>。</li><li><code>mouseenter</code> 不冒泡。只有鼠标真正移入组件自身边界时触发，移入子组件不会再次触发父组件的 <code>mouseenter</code>。</li></ul><h3 id="q-事件对象-e-中的坐标" tabindex="-1">Q: 事件对象 <code>e</code> 中的坐标？ <a class="header-anchor" href="#q-事件对象-e-中的坐标" aria-label="Permalink to &quot;Q: 事件对象 `e` 中的坐标？&quot;">​</a></h3><ul><li><code>e.x</code>, <code>e.y</code>: 相对于 Canvas 左上角的坐标。</li><li><code>e.clientX</code>, <code>e.clientY</code>: 相对于浏览器视口的坐标。</li><li><code>e.target</code>: 实际被点击的最深层节点。</li><li><code>e.currentTarget</code>: 当前绑定事件处理函数的节点。</li></ul>',10))])}const k=n(i,[["render",h]]);export{C as __pageData,k as default};
