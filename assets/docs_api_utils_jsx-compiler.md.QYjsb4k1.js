var c=Object.defineProperty;var t=(o,l)=>c(o,"name",{value:l,configurable:!0});import{$ as i,a5 as s,S as r,V as b,a0 as e,a6 as n,ag as m,W as a}from"./chunks/plugin-vue_export-helper.hykleeSY.js";const G=JSON.parse('{"title":"JSX 编译器","description":"","frontmatter":{"title":"JSX 编译器"},"headers":[],"relativePath":"docs/api/utils/jsx-compiler.md","filePath":"docs/api/utils/jsx-compiler.md"}'),p={name:"docs/api/utils/jsx-compiler.md"};function u(o,l,g,J,I,X){const d=s("InkCodeBlock");return b(),r("div",null,[l[0]||(l[0]=e("h1",{id:"jsx-编译器",tabindex:"-1"},[a("JSX 编译器 "),e("a",{class:"header-anchor",href:"#jsx-编译器","aria-label":'Permalink to "JSX 编译器"'},"​")],-1)),l[1]||(l[1]=e("p",null,[a("JSX 编译器用于把 JSX 元素转换成框架运行时可消费的组件数据（"),e("code",null,"ComponentData"),a("）。常见用法是：在测试/示例中用 JSX 描述 Widget 树，然后调用 "),e("code",null,"compileElement"),a(" 得到数据，再交给 "),e("code",null,"WidgetRegistry"),a(" 创建并挂载。")],-1)),l[2]||(l[2]=e("h2",{id:"核心-api",tabindex:"-1"},[a("核心 API "),e("a",{class:"header-anchor",href:"#核心-api","aria-label":'Permalink to "核心 API"'},"​")],-1)),n(d,{"code-base64":"aW1wb3J0IHsgY29tcGlsZUVsZW1lbnQsIGNvbXBpbGVUZW1wbGF0ZSB9IGZyb20gJ0AvdXRpbHMvY29tcGlsZXIvanN4LWNvbXBpbGVyJzsKaW1wb3J0IHR5cGUgeyBBbnlFbGVtZW50IH0gZnJvbSAnQC91dGlscy9jb21waWxlci9qc3gtY29tcGlsZXInOwo=",lang:"ts",meta:""}),l[3]||(l[3]=e("ul",null,[e("li",null,[e("code",null,"compileElement(element: AnyElement): ComponentData")]),e("li",null,[e("code",null,"compileTemplate"),a(" 是 "),e("code",null,"compileElement"),a(" 的别名")])],-1)),l[4]||(l[4]=e("h2",{id:"基本用法-测试-示例",tabindex:"-1"},[a("基本用法（测试/示例） "),e("a",{class:"header-anchor",href:"#基本用法-测试-示例","aria-label":'Permalink to "基本用法（测试/示例）"'},"​")],-1)),n(d,{"code-base64":"LyoqIEBqc3hJbXBvcnRTb3VyY2UgQC91dGlscy9jb21waWxlciAqLwppbXBvcnQgeyBjb21waWxlRWxlbWVudCB9IGZyb20gJ0AvdXRpbHMvY29tcGlsZXIvanN4LWNvbXBpbGVyJzsKaW1wb3J0IHsgV2lkZ2V0UmVnaXN0cnkgfSBmcm9tICdAL2NvcmUvcmVnaXN0cnknOwppbXBvcnQgeyBjcmVhdGVCb3hDb25zdHJhaW50cyB9IGZyb20gJ0AvY29yZS9iYXNlJzsKaW1wb3J0IHsgQ29udGFpbmVyLCBUZXh0IH0gZnJvbSAnQC9jb3JlJzsKCmltcG9ydCAnQC9jb3JlL3JlZ2lzdHJ5JzsKCmNvbnN0IGVsID0gKAogIDxDb250YWluZXIga2V5PSJyb290IiB3aWR0aD17MjAwfSBoZWlnaHQ9ezEwMH0+CiAgICA8VGV4dCBrZXk9InRpdGxlIiB0ZXh0PSJIZWxsbyIgZm9udFNpemU9ezE2fSAvPgogIDwvQ29udGFpbmVyPgopOwoKY29uc3QgZGF0YSA9IGNvbXBpbGVFbGVtZW50KGVsKTsKY29uc3Qgcm9vdCA9IFdpZGdldFJlZ2lzdHJ5LmNyZWF0ZVdpZGdldChkYXRhKSE7CnJvb3QuY3JlYXRlRWxlbWVudChkYXRhKTsKcm9vdC5sYXlvdXQoY3JlYXRlQm94Q29uc3RyYWludHMoKSk7Cg==",lang:"tsx",meta:""}),l[5]||(l[5]=m('<h2 id="类型解析规则" tabindex="-1">类型解析规则 <a class="header-anchor" href="#类型解析规则" aria-label="Permalink to &quot;类型解析规则&quot;">​</a></h2><ul><li>以组件函数/类的 <code>name</code> 作为默认类型名</li><li>对于函数名以 <code>*Element</code> 结尾的情况，会自动去掉 <code>Element</code> 后缀（例如 <code>TextElement</code> → <code>Text</code>）</li><li>如果传入的是 <code>Widget</code> 子类且尚未注册，会尝试自动注册到 <code>WidgetRegistry</code></li></ul><h2 id="函数组件展开" tabindex="-1">函数组件展开 <a class="header-anchor" href="#函数组件展开" aria-label="Permalink to &quot;函数组件展开&quot;">​</a></h2><p>当 <code>type</code> 为普通函数且不是 <code>Widget</code> 子类时，编译器会把它当作“函数式组件”执行并递归编译返回值。</p><h2 id="事件属性处理" tabindex="-1">事件属性处理 <a class="header-anchor" href="#事件属性处理" aria-label="Permalink to &quot;事件属性处理&quot;">​</a></h2><ul><li>当属性名形如 <code>onClick</code> / <code>onClickCapture</code>（以及其它 onXxx 形式）且组件不是 composite 类型时，编译器会把它解析为事件，并写入内部事件字段（用于后续事件系统注册/派发）</li><li>同时会把函数值原样同步到数据对象上，便于后续构建阶段复用</li></ul>',6))])}t(u,"_sfc_render");const W=i(p,[["render",u]]);export{G as __pageData,W as default};
