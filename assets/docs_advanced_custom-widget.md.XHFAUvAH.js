import{_ as t,C as i,c as d,o as n,ai as o,G as l}from"./chunks/framework.Ckc8SVM3.js";const h=JSON.parse('{"title":"自定义组件","description":"","frontmatter":{"id":"custom-widget","title":"自定义组件","sidebar_position":2},"headers":[],"relativePath":"docs/advanced/custom-widget.md","filePath":"docs/advanced/custom-widget.md"}'),c={name:"docs/advanced/custom-widget.md"};function g(r,e,C,I,s,u){const a=i("InkCodeBlock");return n(),d("div",null,[e[0]||(e[0]=o('<h1 id="自定义组件" tabindex="-1">自定义组件 <a class="header-anchor" href="#自定义组件" aria-label="Permalink to &quot;自定义组件&quot;">​</a></h1><p>Inkwell 提供了两种主要的方式来创建自定义 Widget：<strong>组合 (Composition)</strong> 和 <strong>自定义渲染 (Custom Rendering)</strong>。</p><h2 id="_1-组合方式-render-方法" tabindex="-1">1. 组合方式 (<code>render</code> 方法) <a class="header-anchor" href="#_1-组合方式-render-方法" aria-label="Permalink to &quot;1. 组合方式 (`render` 方法)&quot;">​</a></h2><p>这是最常用也是推荐的方式。通过组合已有的基础组件（如 <code>Container</code>, <code>Row</code>, <code>Text</code>）来构建新的 UI。这种方式类似于 React 的组件开发。</p><h3 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;适用场景&quot;">​</a></h3><ul><li>通用 UI 组件封装（按钮、卡片、表单项）。</li><li>业务页面构建。</li><li>不涉及复杂图形绘制的场景。</li></ul><h3 id="实现方式" tabindex="-1">实现方式 <a class="header-anchor" href="#实现方式" aria-label="Permalink to &quot;实现方式&quot;">​</a></h3><p>继承 <code>StatefulWidget</code> (或 <code>StatelessWidget</code>) 并实现 <code>render</code> 方法。</p><h3 id="代码示例-button-组件" tabindex="-1">代码示例：Button 组件 <a class="header-anchor" href="#代码示例-button-组件" aria-label="Permalink to &quot;代码示例：Button 组件&quot;">​</a></h3><p>参考 <code>src/demo/interactive-counter/widgets/class-button/index.tsx</code>：</p>',10)),l(a,{"code-base64":"LyoqIEBqc3hJbXBvcnRTb3VyY2UgQC91dGlscy9jb21waWxlciAqLwppbXBvcnQgdHlwZSB7IFRoZW1lUGFsZXR0ZSB9IGZyb20gJ0Avc3R5bGVzL3RoZW1lJzsKCmltcG9ydCB7CiAgQ29udGFpbmVyLAogIE1haW5BeGlzQWxpZ25tZW50LAogIFJvdywKICBTdGF0ZWZ1bFdpZGdldCwKICBUZXh0LAogIFRleHRBbGlnbiwKICBUZXh0QWxpZ25WZXJ0aWNhbCwKICB0eXBlIElua3dlbGxFdmVudCwKICB0eXBlIFdpZGdldFByb3BzLAp9IGZyb20gJ0AvY29yZSc7CgppbnRlcmZhY2UgQnV0dG9uUHJvcHMgZXh0ZW5kcyBXaWRnZXRQcm9wcyB7CiAgb25DbGljaz86IChlOiBJbmt3ZWxsRXZlbnQpID0+IHZvaWQ7CiAgdGhlbWU6IFRoZW1lUGFsZXR0ZTsKfQoKZXhwb3J0IGNsYXNzIEJ1dHRvbiBleHRlbmRzIFN0YXRlZnVsV2lkZ2V0PEJ1dHRvblByb3BzPiB7CiAgcmVuZGVyKCkgewogICAgcmV0dXJuICgKICAgICAgPENvbnRhaW5lcgogICAgICAgIGtleT0iY291bnRlci1idG4iCiAgICAgICAgd2lkdGg9ezE4MH0KICAgICAgICBoZWlnaHQ9ezQ4fQogICAgICAgIGNvbG9yPXt0aGlzLnByb3BzLnRoZW1lLnByaW1hcnl9CiAgICAgICAgYm9yZGVyUmFkaXVzPXs4fQogICAgICA+CiAgICAgICAgPFJvdyBtYWluQXhpc0FsaWdubWVudD17TWFpbkF4aXNBbGlnbm1lbnQuQ2VudGVyfT4KICAgICAgICAgIDxUZXh0CiAgICAgICAgICAgIGtleT0iY291bnRlci1idG4tdGV4dC0wMSIKICAgICAgICAgICAgdGV4dD0i54K55Ye7IgogICAgICAgICAgICBmb250U2l6ZT17MTZ9CiAgICAgICAgICAgIGNvbG9yPXt0aGlzLnByb3BzLnRoZW1lLnRleHQuaW52ZXJzZX0KICAgICAgICAgICAgdGV4dEFsaWduPXtUZXh0QWxpZ24uQ2VudGVyfQogICAgICAgICAgICB0ZXh0QWxpZ25WZXJ0aWNhbD17VGV4dEFsaWduVmVydGljYWwuQ2VudGVyfQogICAgICAgICAgLz4KICAgICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufQogICAgICAgIDwvUm93PgogICAgICA8L0NvbnRhaW5lcj4KICAgICk7CiAgfQp9Cg==",lang:"tsx",meta:""}),e[1]||(e[1]=o('<h3 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h3><ul><li><strong>开发效率高</strong>：利用现有组件快速搭建。</li><li>自动布局：无需手动计算尺寸和位置，依赖 Flex 布局系统。</li></ul><hr><h2 id="_2-函数式组件-functional-component" tabindex="-1">2. 函数式组件 (Functional Component) <a class="header-anchor" href="#_2-函数式组件-functional-component" aria-label="Permalink to &quot;2. 函数式组件 (Functional Component)&quot;">​</a></h2><p>这是最轻量级的组件定义方式，适用于无状态的纯展示型组件封装。</p><h3 id="适用场景-1" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景-1" aria-label="Permalink to &quot;适用场景&quot;">​</a></h3><ul><li>简单的 UI 片段复用。</li><li>只有 Props 没有 State 的组件。</li><li>拆分大型 <code>render</code> 函数。</li></ul><h3 id="实现方式-1" tabindex="-1">实现方式 <a class="header-anchor" href="#实现方式-1" aria-label="Permalink to &quot;实现方式&quot;">​</a></h3><p>定义一个接收 <code>props</code> 并返回 JSX 的函数。</p><h3 id="代码示例-section-组件" tabindex="-1">代码示例：Section 组件 <a class="header-anchor" href="#代码示例-section-组件" aria-label="Permalink to &quot;代码示例：Section 组件&quot;">​</a></h3>',10)),l(a,{"code-base64":"Y29uc3QgU2VjdGlvbiA9ICh7IHRpdGxlLCBjaGlsZHJlbiB9OiB7IHRpdGxlOiBzdHJpbmc7IGNoaWxkcmVuOiBhbnkgfSkgPT4gKAogIDxDb2x1bW4gc3BhY2luZz17MTJ9PgogICAgPFRleHQgdGV4dD17dGl0bGV9IGZvbnRTaXplPXsyMH0gZm9udFdlaWdodD0iYm9sZCIgLz4KICAgIDxDb250YWluZXIgcGFkZGluZz17MTZ9IGNvbG9yPSIjRkZGRkZGIj4KICAgICAge2NoaWxkcmVufQogICAgPC9Db250YWluZXI+CiAgPC9Db2x1bW4+Cik7CgovLyDkvb/nlKgKPFNlY3Rpb24gdGl0bGU9IkhlbGxvIj4KICA8VGV4dCB0ZXh0PSJXb3JsZCIgLz4KPC9TZWN0aW9uPgo=",lang:"tsx",meta:""}),e[2]||(e[2]=o('<p><strong>注意</strong>：函数式组件在编译阶段会被展开为它返回的 Widget 树，因此在运行时它不会作为独立的 Widget 存在于树中（类似于内联展开）。</p><hr><h2 id="_3-自定义渲染方式-paintself-方法" tabindex="-1">3. 自定义渲染方式 (<code>paintSelf</code> 方法) <a class="header-anchor" href="#_3-自定义渲染方式-paintself-方法" aria-label="Permalink to &quot;3. 自定义渲染方式 (`paintSelf` 方法)&quot;">​</a></h2><p>当你需要完全控制绘制逻辑，或者需要绘制标准组件无法实现的图形（如图表、仪表盘、自定义形状）时，使用此方式。</p><h3 id="适用场景-2" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景-2" aria-label="Permalink to &quot;适用场景&quot;">​</a></h3><ul><li>图表库 (Charts)。</li><li>游戏画面。</li><li>复杂的几何图形。</li><li>需要极致性能的原子组件。</li></ul><h3 id="实现方式-2" tabindex="-1">实现方式 <a class="header-anchor" href="#实现方式-2" aria-label="Permalink to &quot;实现方式&quot;">​</a></h3><p>继承 <code>Widget</code> 类，并重写 <code>performLayout</code> 和 <code>paintSelf</code> 方法。</p><h3 id="代码示例-circle-组件" tabindex="-1">代码示例：Circle 组件 <a class="header-anchor" href="#代码示例-circle-组件" aria-label="Permalink to &quot;代码示例：Circle 组件&quot;">​</a></h3>',9)),l(a,{"code-base64":"aW1wb3J0IHsKICBXaWRnZXQsCiAgdHlwZSBCb3hDb25zdHJhaW50cywKICB0eXBlIEJ1aWxkQ29udGV4dCwKICB0eXBlIFNpemUsCiAgdHlwZSBXaWRnZXRQcm9wcywKfSBmcm9tICdAL2NvcmUvYmFzZSc7CgppbnRlcmZhY2UgQ2lyY2xlUHJvcHMgZXh0ZW5kcyBXaWRnZXRQcm9wcyB7CiAgcmFkaXVzOiBudW1iZXI7CiAgY29sb3I6IHN0cmluZzsKfQoKZXhwb3J0IGNsYXNzIENpcmNsZSBleHRlbmRzIFdpZGdldDxDaXJjbGVQcm9wcz4gewogIGNvbnN0cnVjdG9yKHByb3BzOiBDaXJjbGVQcm9wcykgewogICAgc3VwZXIocHJvcHMpOwogIH0KCiAgLy8gMS4g5b+F6aG75a6e546w5biD5bGA6YC76L6R77yM5ZGK6K+J54i257uE5Lu26Ieq5bex5aSa5aSnCiAgcHJvdGVjdGVkIHBlcmZvcm1MYXlvdXQoY29uc3RyYWludHM6IEJveENvbnN0cmFpbnRzLCBfY2hpbGRyZW5TaXplczogU2l6ZVtdKTogU2l6ZSB7CiAgICBjb25zdCBkaWFtZXRlciA9IHRoaXMucHJvcHMucmFkaXVzICogMjsKICAgIC8vIOehruS/neWwuuWvuOS4jei2hei/h+eItue7hOS7tue6puadnwogICAgcmV0dXJuIHsKICAgICAgd2lkdGg6IE1hdGgubWluKGRpYW1ldGVyLCBjb25zdHJhaW50cy5tYXhXaWR0aCksCiAgICAgIGhlaWdodDogTWF0aC5taW4oZGlhbWV0ZXIsIGNvbnN0cmFpbnRzLm1heEhlaWdodCksCiAgICB9OwogIH0KCiAgLy8gMi4g5a6e546w57uY5Yi26YC76L6RCiAgcHJvdGVjdGVkIHBhaW50U2VsZihjb250ZXh0OiBCdWlsZENvbnRleHQpOiB2b2lkIHsKICAgIGNvbnN0IHsgcmVuZGVyZXIgfSA9IGNvbnRleHQ7CiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMucmVuZGVyT2JqZWN0LnNpemU7CiAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7CiAgICBjb25zdCBjdHggPSByZW5kZXJlci5nZXRSYXdJbnN0YW5jZSgpIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGw7CiAgICBpZiAoIWN0eCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgY3R4LmJlZ2luUGF0aCgpOwogICAgY3R4LmFyYyh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpOwogICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMucHJvcHMuY29sb3I7CiAgICBjdHguZmlsbCgpOwogIH0KfQo=",lang:"tsx",meta:""}),e[3]||(e[3]=o('<h3 id="性能注意事项" tabindex="-1">性能注意事项 <a class="header-anchor" href="#性能注意事项" aria-label="Permalink to &quot;性能注意事项&quot;">​</a></h3><ul><li><strong>paintSelf 调用频繁</strong>：每一帧都可能调用，避免在 <code>paintSelf</code> 中创建对象或进行复杂计算。</li><li><strong>坐标系</strong>：<code>paintSelf</code> 中的坐标是相对于组件左上角的（局部坐标），<code>renderer</code> 会自动处理全局变换。</li></ul><hr><h2 id="_4-实战案例-interactive-counter-组件对比" tabindex="-1">4. 实战案例：Interactive Counter 组件对比 <a class="header-anchor" href="#_4-实战案例-interactive-counter-组件对比" aria-label="Permalink to &quot;4. 实战案例：Interactive Counter 组件对比&quot;">​</a></h2><p>在 <code>src/demo/interactive-counter</code> 示例中，展示了三种不同的组件实现方式来构建同一个按钮功能。这有助于理解不同方式的特性和适用场景。</p><h3 id="_4-1-class-component-classbutton" tabindex="-1">4.1 Class Component (<code>ClassButton</code>) <a class="header-anchor" href="#_4-1-class-component-classbutton" aria-label="Permalink to &quot;4.1 Class Component (`ClassButton`)&quot;">​</a></h3><ul><li><strong>路径</strong>: <code>widgets/class-button/index.tsx</code></li><li><strong>特点</strong>: 标准的 <code>StatefulWidget</code>。</li><li><strong>优势</strong>: 完整的生命周期支持，可以使用 <code>setState</code> 管理内部状态（如 hover 态）。</li><li><strong>实现</strong>: <code>render()</code> 方法返回 <code>Container</code> 和 <code>Text</code> 的组合。</li></ul><h3 id="_4-2-functional-component-functionalbutton" tabindex="-1">4.2 Functional Component (<code>FunctionalButton</code>) <a class="header-anchor" href="#_4-2-functional-component-functionalbutton" aria-label="Permalink to &quot;4.2 Functional Component (`FunctionalButton`)&quot;">​</a></h3><ul><li><strong>路径</strong>: <code>widgets/functional-button/index.tsx</code></li><li><strong>特点</strong>: 无状态函数。</li><li><strong>优势</strong>: 写法极其简洁，无 <code>this</code> 上下文负担。</li><li><strong>实现</strong>: 仅仅是一个返回 JSX 的函数。</li></ul><h3 id="_4-3-raw-widget-rawbutton" tabindex="-1">4.3 Raw Widget (<code>RawButton</code>) <a class="header-anchor" href="#_4-3-raw-widget-rawbutton" aria-label="Permalink to &quot;4.3 Raw Widget (`RawButton`)&quot;">​</a></h3><ul><li><strong>路径</strong>: <code>widgets/raw-button/index.ts</code></li><li><strong>特点</strong>: 直接继承 <code>Widget</code>，无 <code>render</code> 方法。</li><li><strong>优势</strong>: 极致的性能控制，直接操作 Canvas 指令，无子组件树开销。</li><li><strong>实现</strong>: 实现了 <code>performLayout</code> (计算尺寸) 和 <code>paintSelf</code> (绘制矩形和文字)。</li></ul><hr><h2 id="_5-注意事项-事件绑定的双重触发" tabindex="-1">5. 注意事项：事件绑定的双重触发 <a class="header-anchor" href="#_5-注意事项-事件绑定的双重触发" aria-label="Permalink to &quot;5. 注意事项：事件绑定的双重触发&quot;">​</a></h2><p>在开发自定义组件（尤其是“外层是复合组件、内层用基础组件组合”的场景）时，需要注意事件绑定位置，否则可能出现同一个回调被触发多次。</p><h3 id="现象" tabindex="-1">现象 <a class="header-anchor" href="#现象" aria-label="Permalink to &quot;现象&quot;">​</a></h3><p>如果外层组件绑定了 <code>onClick</code>，同时又把同一个 <code>onClick</code> 继续传给内部可命中的子组件（例如 <code>Container</code>），在冒泡阶段可能会触发两次：先命中内层，再冒泡到外层。</p><h3 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h3><p>Inkwell 的事件系统支持捕获/冒泡。一次点击命中目标节点后，会沿着祖先链路继续分发（冒泡阶段）。当同一回调同时绑定在多层节点上时，就会出现重复调用。</p><p>同时也需要注意：事件分发时“类方法优先”。如果你在组件实例上实现了 <code>onClick/onClickCapture</code> 等同名方法，那么通过 JSX 属性注册到事件系统的处理器会被忽略；此时若你仍希望外部传入的 <code>props.onClick</code> 生效，需要在类方法中自行转发。</p><h3 id="示例代码" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码" aria-label="Permalink to &quot;示例代码&quot;">​</a></h3>',20)),l(a,{"code-base64":"ZXhwb3J0IGNsYXNzIFJhd0J1dHRvbiBleHRlbmRzIFdpZGdldDxSYXdCdXR0b25Qcm9wcz4gewogIC8vIC4uLgoKICAvLyDinIUg57G75pa55rOV5LyY5YWI77ya5aaC5p6c5L2g5a6e546w5LqGIG9uQ2xpY2vvvIxKU1gg5bGe5oCn5rOo5YaM55qE5aSE55CG5Zmo5bCG6KKr5b+955WlCiAgb25DbGljayhlOiBJbmt3ZWxsRXZlbnQpIHsKICAgIC8vIOWPr+S7peWcqOi/memHjOaJp+ihjOWGhemDqOmAu+i+kQogICAgLy8g5aaC5p6c5L2g5biM5pyb5aSW6YOo5Lyg5YWl55qEIG9uQ2xpY2sg55Sf5pWI77yM6ZyA6KaB5omL5Yqo6L2s5Y+RCiAgICB0aGlzLnByb3BzLm9uQ2xpY2s/LihlKTsKICB9Cn0K",lang:"typescript",meta:""}),e[4]||(e[4]=o('<h3 id="最佳实践建议" tabindex="-1">最佳实践建议 <a class="header-anchor" href="#最佳实践建议" aria-label="Permalink to &quot;最佳实践建议&quot;">​</a></h3><ol><li><p><strong>一个回调只绑定一层</strong></p><ul><li>外层组件需要响应点击时，不要再把同一个 <code>onClick</code> 继续传给内部 <code>Container</code>/<code>Row</code> 等子节点。</li><li>如果确实需要内层节点处理事件，则外层避免再绑定相同回调，或在外层根据 event.target 做过滤。</li></ul></li><li><p><strong>明确类方法与 JSX 属性的优先级</strong></p><ul><li>你实现了 <code>onClick</code> 类方法时，JSX 属性注册的处理器会被忽略。</li><li>因此“外部回调是否触发”由你的类方法决定：需要则转发，不需要则不转发。</li></ul></li></ol>',2))])}const A=t(c,[["render",g]]);export{h as __pageData,A as default};
