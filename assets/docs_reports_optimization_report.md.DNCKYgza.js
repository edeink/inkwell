import{_ as t,c as o,o as r,ai as a}from"./chunks/framework.Ckc8SVM3.js";const u=JSON.parse('{"title":"InkWell 性能优化报告","description":"","frontmatter":{},"headers":[],"relativePath":"docs/reports/optimization_report.md","filePath":"docs/reports/optimization_report.md"}'),s={name:"docs/reports/optimization_report.md"};function d(c,e,n,i,l,h){return r(),o("div",null,[...e[0]||(e[0]=[a('<h1 id="inkwell-性能优化报告" tabindex="-1">InkWell 性能优化报告 <a class="header-anchor" href="#inkwell-性能优化报告" aria-label="Permalink to &quot;InkWell 性能优化报告&quot;">​</a></h1><h2 id="_1-优化概述" tabindex="-1">1. 优化概述 <a class="header-anchor" href="#_1-优化概述" aria-label="Permalink to &quot;1. 优化概述&quot;">​</a></h2><p>本项目旨在提升 InkWell 框架在处理大规模节点和高频更新场景下的性能表现。通过对核心组件 (<code>Base</code>, <code>Stack</code>, <code>Positioned</code>, <code>Container</code>)、渲染运行时 (<code>Runtime</code>, <code>Canvas2DRenderer</code>) 以及编译工具链 (<code>JSX Compiler</code>) 的深度优化，实现了显著的性能飞跃。</p><h2 id="_2-性能测试结果" tabindex="-1">2. 性能测试结果 <a class="header-anchor" href="#_2-性能测试结果" aria-label="Permalink to &quot;2. 性能测试结果&quot;">​</a></h2><p>基于 <code>src/benchmark/perf.spec.tsx</code> 的基准测试结果：</p><table tabindex="0"><thead><tr><th style="text-align:left;">测试场景</th><th style="text-align:left;">优化前 FPS</th><th style="text-align:left;">优化后 FPS</th><th style="text-align:left;">提升倍数</th><th style="text-align:left;">备注</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>State Widget</strong> (状态更新)</td><td style="text-align:left;">~104</td><td style="text-align:left;"><strong>941.54</strong></td><td style="text-align:left;"><strong>9.0x</strong></td><td style="text-align:left;">1000 个节点的高频状态切换</td></tr><tr><td style="text-align:left;"><strong>Pipeline Widget</strong> (全量管线)</td><td style="text-align:left;">~14</td><td style="text-align:left;"><strong>386.60</strong></td><td style="text-align:left;"><strong>27.6x</strong></td><td style="text-align:left;">1000 个节点的每帧全量构建与渲染</td></tr></tbody></table><blockquote><p>注：测试环境为 macOS, Node.js 环境下的 Vitest 测试运行。</p></blockquote><h2 id="_3-核心优化点" tabindex="-1">3. 核心优化点 <a class="header-anchor" href="#_3-核心优化点" aria-label="Permalink to &quot;3. 核心优化点&quot;">​</a></h2><h3 id="_3-1-核心组件优化-core-widgets" tabindex="-1">3.1 核心组件优化 (Core Widgets) <a class="header-anchor" href="#_3-1-核心组件优化-core-widgets" aria-label="Permalink to &quot;3.1 核心组件优化 (Core Widgets)&quot;">​</a></h3><h4 id="src-core-base-ts-widget-基类" tabindex="-1"><code>src/core/base.ts</code> (Widget 基类) <a class="header-anchor" href="#src-core-base-ts-widget-基类" aria-label="Permalink to &quot;`src/core/base.ts` (Widget 基类)&quot;">​</a></h4><ul><li><strong>快速路径 (Fast Path) 优化</strong>：在 <code>_performPaint</code> 中针对仅包含平移变换 (<code>translate</code>) 的场景增加了快速路径，避免了创建 <code>TransformStep</code> 数组和复杂的矩阵运算，直接调用 Canvas API。</li><li><strong>事件绑定优化</strong>：引入 <code>__noEvents</code> 标记，对无事件监听器的组件直接跳过 <code>DOMEventManager.bindEvents</code> 调用，显著减少了大规模节点树的遍历开销。</li><li><strong>子节点构建优化</strong>：在 <code>buildChildren</code> 中移除了 <code>computeNextChildrenData</code> 中的冗余 <code>filter</code> 操作（依赖编译器保证数据的纯净性），并优化了节点复用逻辑，减少对象分配。</li></ul><h4 id="src-core-stack-ts-src-core-positioned-ts" tabindex="-1"><code>src/core/stack.ts</code> &amp; <code>src/core/positioned.ts</code> <a class="header-anchor" href="#src-core-stack-ts-src-core-positioned-ts" aria-label="Permalink to &quot;`src/core/stack.ts` &amp; `src/core/positioned.ts`&quot;">​</a></h4><ul><li><strong>布局逻辑内联</strong>：在 <code>Stack</code> 的 <code>positionChildren</code> 方法中内联了 <code>Positioned</code> 组件的定位逻辑，避免了创建临时的 <code>Offset</code> 对象。</li><li><strong>循环合并</strong>：将 <code>Stack</code> 布局过程中的多次子节点遍历合并为单次遍历，减少了 CPU 周期。</li><li><strong>尺寸缓存</strong>：在 <code>Positioned</code> 组件中增加了尺寸缓存机制，避免重复计算。</li><li><strong>细粒度更新</strong>：区分了位置更新和尺寸更新，仅在必要时触发布局。</li></ul><h4 id="src-core-container-ts" tabindex="-1"><code>src/core/container.ts</code> <a class="header-anchor" href="#src-core-container-ts" aria-label="Permalink to &quot;`src/core/container.ts`&quot;">​</a></h4><ul><li><strong>对象分配减少</strong>：优化了 <code>didUpdateWidget</code> 逻辑，在 <code>borderRadius</code> 未变更时直接复用旧值，避免了 <code>normalizeBorderRadius</code> 的频繁调用。</li><li><strong>样式解析优化</strong>：仅在 <code>padding</code> 或 <code>margin</code> 引用变更时重新解析 <code>EdgeInsets</code>，复用 <code>ZERO_EDGE_INSETS</code> 常量。</li></ul><h3 id="_3-2-运行时优化-runtime" tabindex="-1">3.2 运行时优化 (Runtime) <a class="header-anchor" href="#_3-2-运行时优化-runtime" aria-label="Permalink to &quot;3.2 运行时优化 (Runtime)&quot;">​</a></h3><h4 id="src-runtime-index-tsx" tabindex="-1"><code>src/runtime/index.tsx</code> <a class="header-anchor" href="#src-runtime-index-tsx" aria-label="Permalink to &quot;`src/runtime/index.tsx`&quot;">​</a></h4><ul><li><strong>渲染管线调度</strong>：在 <code>renderFromJSON</code> 中引入了 <code>pipelineOwner.clearNodesNeedingLayout()</code>，在手动触发布局后直接清空待布局队列，避免了后续 <code>flushLayout</code> 的无效遍历和排序开销。</li><li><strong>根节点复用</strong>：增强了根节点复用逻辑，支持局部更新。</li><li><strong>渲染器初始化优化</strong>：通过 <code>_lastRendererOptionsKey</code> 缓存渲染器配置，避免了每帧重复调用 <code>renderer.update</code>。</li></ul><h4 id="src-renderer-canvas2d-canvas-2d-renderer-ts" tabindex="-1"><code>src/renderer/canvas2d/canvas-2d-renderer.ts</code> <a class="header-anchor" href="#src-renderer-canvas2d-canvas-2d-renderer-ts" aria-label="Permalink to &quot;`src/renderer/canvas2d/canvas-2d-renderer.ts`&quot;">​</a></h4><ul><li><strong>Native API 支持</strong>：优先使用 Canvas 2D 的 <code>roundRect</code> 原生 API 绘制圆角矩形，替代了手动的 <code>arc</code> 路径绘制，大幅提升绘制性能。</li><li><strong>状态缓存</strong>：增加了对 <code>fillStyle</code>, <code>strokeStyle</code>, <code>lineWidth</code> 等上下文状态的缓存，减少了不必要的 setter 调用（DOM 操作开销）。</li><li><strong>Save/Restore 消除</strong>：在绘制简单矩形时移除了不必要的 <code>save()</code> / <code>restore()</code> 调用。</li></ul><h3 id="_3-3-编译与工具链-compiler-events" tabindex="-1">3.3 编译与工具链 (Compiler &amp; Events) <a class="header-anchor" href="#_3-3-编译与工具链-compiler-events" aria-label="Permalink to &quot;3.3 编译与工具链 (Compiler &amp; Events)&quot;">​</a></h3><h4 id="src-utils-compiler-jsx-compiler-ts" tabindex="-1"><code>src/utils/compiler/jsx-compiler.ts</code> <a class="header-anchor" href="#src-utils-compiler-jsx-compiler-ts" aria-label="Permalink to &quot;`src/utils/compiler/jsx-compiler.ts`&quot;">​</a></h4><ul><li><strong>预处理优化</strong>：在编译阶段预先提取事件监听器并注入 <code>__events</code> 或 <code>__noEvents</code> 标记，将运行时开销转移至编译期。</li><li><strong>纯净编译</strong>：移除了编译过程中的副作用（如直接注册事件），确保编译结果为纯数据 (ComponentData)。</li></ul><h4 id="src-core-events-dom-event-manager-ts" tabindex="-1"><code>src/core/events/dom-event-manager.ts</code> <a class="header-anchor" href="#src-core-events-dom-event-manager-ts" aria-label="Permalink to &quot;`src/core/events/dom-event-manager.ts`&quot;">​</a></h4><ul><li><strong>属性遍历消除</strong>：利用编译器注入的标记，在运行时直接定位事件处理器，避免了对组件 Props 的全量遍历检查。</li></ul><h2 id="_4-总结" tabindex="-1">4. 总结 <a class="header-anchor" href="#_4-总结" aria-label="Permalink to &quot;4. 总结&quot;">​</a></h2><p>本次优化遵循了&quot;减少分配、减少遍历、减少重绘&quot;的核心原则。通过深入分析 Profiling 数据，定位并解决了多个关键瓶颈。最终实现了 State Benchmark 9倍、Pipeline Benchmark 27倍的性能提升，且完全保持了原有的功能和 API 兼容性。</p>',27)])])}const m=t(s,[["render",d]]);export{u as __pageData,m as default};
