import{_ as a,C as n,c as r,o as c,j as o,G as i,ai as d,a as l}from"./chunks/framework.Ckc8SVM3.js";const m=JSON.parse('{"title":"交互式计数器 (Interactive Counter)","description":"","frontmatter":{},"headers":[],"relativePath":"src/demo/interactive-counter/README.md","filePath":"src/demo/interactive-counter/README.md"}'),g={name:"src/demo/interactive-counter/README.md"};function I(s,e,C,u,A,p){const t=n("InkCodeBlock");return c(),r("div",null,[e[0]||(e[0]=o("h1",{id:"交互式计数器-interactive-counter",tabindex:"-1"},[l("交互式计数器 (Interactive Counter) "),o("a",{class:"header-anchor",href:"#交互式计数器-interactive-counter","aria-label":'Permalink to "交互式计数器 (Interactive Counter)"'},"​")],-1)),e[1]||(e[1]=o("p",null,[l("这是一个展示 "),o("code",null,"@edeink/inkwell"),l(" 框架核心功能的交互式演示项目。通过实现一个简单的计数器应用，展示了组件化开发、状态管理、事件处理和多种组件实现方式。")],-1)),e[2]||(e[2]=o("h2",{id:"目录结构",tabindex:"-1"},[l("目录结构 "),o("a",{class:"header-anchor",href:"#目录结构","aria-label":'Permalink to "目录结构"'},"​")],-1)),i(t,{"code-base64":"c3JjL2RlbW8vaW50ZXJhY3RpdmUtY291bnRlci8K4pSc4pSA4pSAIF9fdGVzdHNfXy8gICAgICAgICAgICAgICAgICAjIOa1i+ivleeUqOS+i+ebruW9lQrilIIgICDilJzilIDilIAgYmluZC1hbmQtZGlzcGF0Y2guc3BlYy50c3gK4pSCICAg4pSc4pSA4pSAIGJ1dHRvbi1saWZlY3ljbGUuc3BlYy50c3gK4pSCICAg4pSU4pSA4pSAIC4uLgrilJzilIDilIAgd2lkZ2V0cy8gICAgICAgICAgICAgICAgICAgICMg6Ieq5a6a5LmJ57uE5Lu255uu5b2VCuKUgiAgIOKUnOKUgOKUgCBjbGFzcy1idXR0b24vICAgICAgICAgICAjIOexu+e7hOS7tuWunueOsOekuuS+iwrilIIgICDilJzilIDilIAgZnVuY3Rpb25hbC1idXR0b24vICAgICAgIyDlh73mlbDlvI/nu4Tku7blrp7njrDnpLrkvosK4pSCICAg4pSc4pSA4pSAIHJhdy1idXR0b24vICAgICAgICAgICAgICMg5Y6f55Sf5riy5p+T5a+56LGh57uE5Lu256S65L6LCuKUgiAgIOKUlOKUgOKUgCBwZXJmb3JtYW5jZS1tb25pdG9yLyAgICAjIOaAp+iDveebkeaOp+e7hOS7tgrilJzilIDilIAgYXBwLnRzeCAgICAgICAgICAgICAgICAgICAgICMg5bqU55So5Li75YWl5Y+j57uE5Lu2CuKUnOKUgOKUgCBpbmRleC50c3ggICAgICAgICAgICAgICAgICAgIyDlpJbpg6jmjILovb3lhaXlj6MK4pSc4pSA4pSAIGluZGV4Lm1vZHVsZS5sZXNzICAgICAgICAgICAjIOagt+W8j+aWh+S7tgrilJTilIDilIAgdHlwZS50cyAgICAgICAgICAgICAgICAgICAgICMg57G75Z6L5a6a5LmJCg==",lang:"",meta:""}),e[3]||(e[3]=d('<h2 id="核心架构与实现" tabindex="-1">核心架构与实现 <a class="header-anchor" href="#核心架构与实现" aria-label="Permalink to &quot;核心架构与实现&quot;">​</a></h2><h3 id="_1-组件实现多样性" tabindex="-1">1. 组件实现多样性 <a class="header-anchor" href="#_1-组件实现多样性" aria-label="Permalink to &quot;1. 组件实现多样性&quot;">​</a></h3><p>本项目展示了在 Inkwell 框架中创建组件的三种主要方式，旨在帮助开发者理解不同抽象层级的组件开发模式：</p><ul><li><p><strong>Class Component (<code>ClassButton</code>)</strong>:</p><ul><li>继承自 <code>StatefulWidget</code> 或 <code>StatelessWidget</code>。</li><li>使用面向对象的方式管理生命周期和状态。</li><li>适合逻辑复杂、需要精细控制生命周期的组件。</li></ul></li><li><p><strong>Functional Component (<code>FunctionalButton</code>)</strong>:</p><ul><li>使用纯函数定义组件。</li><li>语法简洁，易于编写和测试。</li><li>适合展示型组件或逻辑较简单的场景。</li></ul></li><li><p><strong>Raw Widget (<code>RawButton</code>)</strong>:</p><ul><li>直接操作 <code>RenderObject</code>。</li><li>继承自 <code>RenderObjectWidget</code>。</li><li>提供了最低层级的绘制控制（Canvas API），用于高性能或自定义绘制需求。</li></ul></li></ul><h3 id="_2-交互逻辑与状态管理" tabindex="-1">2. 交互逻辑与状态管理 <a class="header-anchor" href="#_2-交互逻辑与状态管理" aria-label="Permalink to &quot;2. 交互逻辑与状态管理&quot;">​</a></h3><p><code>InteractiveCounterDemo</code> (<code>app.tsx</code>) 作为顶层容器组件，管理着整个应用的共享状态：</p><ul><li><strong>状态定义</strong>: <code>state</code> 中维护了 <code>count</code> (计数)。</li><li><strong>事件处理</strong>: <code>onInc</code> 方法作为统一的回调函数，被传递给所有子按钮组件。</li><li><strong>状态更新</strong>: 当任意按钮被点击时，触发 <code>onInc</code>，调用 <code>this.setState</code> 更新 <code>count</code>，从而触发整个组件树的重新构建（Re-build）。</li></ul><h3 id="_3-性能监控与-ref-通信" tabindex="-1">3. 性能监控与 Ref 通信 <a class="header-anchor" href="#_3-性能监控与-ref-通信" aria-label="Permalink to &quot;3. 性能监控与 Ref 通信&quot;">​</a></h3><p>项目包含一个 <code>PerformanceMonitor</code> 组件，用于展示性能优化和组件间通信：</p><ul><li><strong>Ref 通信</strong>: 父组件通过 <code>ref</code> 获取 <code>PerformanceMonitor</code> 的实例引用 (<code>this.monitorRef</code>)。</li><li><strong>命令式更新</strong>: 在 <code>onInc</code> 方法中，除了更新 React 状态外，还直接调用 <code>this.monitorRef.flash()</code> 方法，触发监控器的动画效果。这展示了如何在声明式框架中处理必要的命令式逻辑。</li></ul><h2 id="技术栈与依赖" tabindex="-1">技术栈与依赖 <a class="header-anchor" href="#技术栈与依赖" aria-label="Permalink to &quot;技术栈与依赖&quot;">​</a></h2><ul><li><strong>Core Framework</strong>: <code>@edeink/inkwell</code> (核心渲染引擎)</li><li><strong>Runtime</strong>: <code>Runtime</code> (运行时环境，负责调度和渲染循环)</li><li><strong>Styling</strong>: <code>ThemePalette</code> (主题系统)</li><li><strong>Testing</strong>: Vitest (单元测试框架)</li></ul><h2 id="代码执行流程" tabindex="-1">代码执行流程 <a class="header-anchor" href="#代码执行流程" aria-label="Permalink to &quot;代码执行流程&quot;">​</a></h2><ol><li><strong>初始化</strong>: <code>runApp</code> 函数被调用，初始化 <code>Runtime</code> 并挂载 <code>InteractiveCounterDemo</code> 组件。</li><li><strong>构建</strong>: <code>InteractiveCounterDemo</code> 的 <code>render</code> 方法被执行，构建包含 <code>Column</code>、<code>Row</code> 以及三种 <code>Button</code> 和 <code>PerformanceMonitor</code> 的组件树。</li><li><strong>渲染</strong>: Inkwell 引擎将组件树转换为 RenderObject 树，并绘制到 Canvas 上。</li><li><strong>交互</strong>: <ul><li>用户点击任意按钮 (Class/Functional/Raw)。</li><li>触发 <code>onInc</code> 回调。</li><li><code>setState</code> 更新 <code>count</code>。</li><li><code>PerformanceMonitor.flash()</code> 被调用。</li></ul></li><li><strong>更新</strong>: 引擎检测到状态变化，触发 Layout 和 Paint 流程，更新界面显示。</li></ol><h2 id="关键代码示例" tabindex="-1">关键代码示例 <a class="header-anchor" href="#关键代码示例" aria-label="Permalink to &quot;关键代码示例&quot;">​</a></h2><p><strong>主组件状态管理 (<code>app.tsx</code>):</strong></p>',16)),i(t,{"code-base64":"ZXhwb3J0IGNsYXNzIEludGVyYWN0aXZlQ291bnRlckRlbW8gZXh0ZW5kcyBTdGF0ZWZ1bFdpZGdldDxQcm9wcywgU3RhdGU+IHsKICAvLyAuLi4KICBwcml2YXRlIG9uSW5jID0gKCk6IHZvaWQgPT4gewogICAgLy8g5pu05paw6Ieq6Lqr54q25oCBCiAgICB0aGlzLnNldFN0YXRlKHsgY291bnQ6IHRoaXMuc3RhdGUuY291bnQgKyAxIH0pOwoKICAgIC8vIOaAp+iDveebkeaOp+WZqOmXqueDgSAoUmVm6YCa5L+hKQogICAgaWYgKHRoaXMubW9uaXRvclJlZikgewogICAgICB0aGlzLm1vbml0b3JSZWYuZmxhc2goKTsKICAgIH0KICB9OwogIC8vIC4uLgp9Cg==",lang:"typescript",meta:""})])}const b=a(g,[["render",I]]);export{m as __pageData,b as default};
