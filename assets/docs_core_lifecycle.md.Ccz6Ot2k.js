var s=Object.defineProperty;var i=(r,t)=>s(r,"name",{value:t,configurable:!0});import{_ as g,C as l,c as u,o as I,ai as e,G as d,j as a,a as c}from"./chunks/framework.BnOgjZe9.js";const k=JSON.parse('{"title":"生命周期","description":"","frontmatter":{"id":"lifecycle","title":"生命周期","sidebar_position":1},"headers":[],"relativePath":"docs/core/lifecycle.md","filePath":"docs/core/lifecycle.md"}'),h={name:"docs/core/lifecycle.md"};function m(r,t,p,C,b,A){const n=l("InkMermaidBlock"),o=l("InkCodeBlock");return I(),u("div",null,[t[0]||(t[0]=e('<h1 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h1><p>Inkwell 的组件生命周期参考了常见的 UI 框架模型，整体可以拆分为四个主要阶段：<strong>Mount（挂载/初始化）</strong>、<strong>Update（更新）</strong>、<strong>Layout（布局）</strong> 和 <strong>Paint（绘制）</strong>。</p><h2 id="生命周期流程图" tabindex="-1">生命周期流程图 <a class="header-anchor" href="#生命周期流程图" aria-label="Permalink to &quot;生命周期流程图&quot;">​</a></h2>',3)),d(n,{"code-base64":"Z3JhcGggTFIKICAgIHN1YmdyYXBoIE1vdW50WyLmjILovb3pmLbmrrUiXQogICAgICAgIEFbImNvbnN0cnVjdG9yIl0gLS0+IEJbImluaXRXaWRnZXQiXQogICAgZW5kCgogICAgc3ViZ3JhcGggVXBkYXRlWyLmm7TmlrDpmLbmrrUiXQogICAgICAgIEIgLS0+IENbImNyZWF0ZUVsZW1lbnQocHJvcHMpIl0KICAgICAgICBDIC0tPiBEWyJyZW5kZXIoKSDnvJbor5HlrZDmoJEiXQogICAgICAgIEQgLS0+IEV7ImRpcnR5PyJ9CiAgICAgICAgRSAtLSAi5pivIiAtLT4gRlsicmVidWlsZCJdCiAgICAgICAgRiAtLT4gR1si5a2Q6IqC54K55aSN55SoL+WinuWIoCJdCiAgICBlbmQKCiAgICBzdWJncmFwaCBMYXlvdXRbIuW4g+WxgOmYtuautSJdCiAgICAgICAgRyAtLT4gSFsibWFya05lZWRzTGF5b3V0Il0KICAgICAgICBIIC0tPiBJWyJsYXlvdXQiXQogICAgICAgIEkgLS0+IEpbInBlcmZvcm1MYXlvdXQiXQogICAgICAgIEogLS0+IEtbInBvc2l0aW9uQ2hpbGRyZW4iXQogICAgZW5kCgogICAgc3ViZ3JhcGggUGFpbnRbIue7mOWItumYtuautSJdCiAgICAgICAgSyAtLT4gTFsibWFya05lZWRzUGFpbnQiXQogICAgICAgIEwgLS0+IE1bInBhaW50Il0KICAgICAgICBNIC0tPiBOWyJwYWludFNlbGYiXQogICAgICAgIE4gLS0+IE9bIumAkuW9kue7mOWItuWtkOiKgueCuSJdCiAgICBlbmQKCiAgICBzdWJncmFwaCBVbm1vdW50WyLljbjovb3pmLbmrrUiXQogICAgICAgIFBbImRpc3Bvc2UiXQogICAgZW5kCgogICAgTyAtLT4gUAo="}),t[1]||(t[1]=e('<h2 id="核心阶段详解" tabindex="-1">核心阶段详解 <a class="header-anchor" href="#核心阶段详解" aria-label="Permalink to &quot;核心阶段详解&quot;">​</a></h2><h3 id="_1-mount-挂载" tabindex="-1">1. Mount (挂载) <a class="header-anchor" href="#_1-mount-挂载" aria-label="Permalink to &quot;1. Mount (挂载)&quot;">​</a></h3><p>组件被首次创建并插入到 Widget 树中。</p><table tabindex="0"><thead><tr><th>方法</th><th>描述</th><th>典型用途</th></tr></thead><tbody><tr><td><code>constructor</code></td><td>组件实例化</td><td>初始化字段、缓存、订阅句柄等</td></tr><tr><td><code>initWidget</code></td><td>一次性初始化钩子</td><td>初始化状态、订阅事件、启动定时器等（只会调用一次）</td></tr><tr><td><code>isMounted</code></td><td>挂载状态检查</td><td>判断当前节点是否已经接入 <code>PipelineOwner</code>（具备布局/绘制调度能力）</td></tr></tbody></table><p><code>initWidget</code> 是 Inkwell 的“一次性初始化”入口。<code>StatelessWidget/StatefulWidget</code> 会在首次 <code>createElement</code> 时确保调用它。</p><h3 id="_2-update-更新" tabindex="-1">2. Update (更新) <a class="header-anchor" href="#_2-update-更新" aria-label="Permalink to &quot;2. Update (更新)&quot;">​</a></h3><p>当父组件重建或自身 State 改变（<code>setState</code> -&gt; 内部调用 <code>markDirty</code>）时触发。</p><table tabindex="0"><thead><tr><th>方法</th><th>描述</th><th>典型用途</th></tr></thead><tbody><tr><td><code>createElement</code></td><td>接收新 Props 并更新</td><td>框架更新入口（数据更新、子节点复用、必要时触发生命周期）</td></tr><tr><td><code>render</code></td><td>返回声明式子树</td><td><code>StatelessWidget/StatefulWidget</code> 通过 <code>render()</code> 返回 JSX（或等价元素），由编译器转为 <code>ComponentData</code></td></tr><tr><td><code>didUpdateWidget</code></td><td>响应 Props 变更</td><td>对比新旧 Props，同步内部状态或处理副作用；默认行为是 <code>markNeedsLayout()</code></td></tr><tr><td><code>rebuild</code></td><td>脏节点重建</td><td>由 Runtime 批量消费脏节点，驱动子树更新</td></tr><tr><td><code>markDirty</code></td><td>标记脏节点</td><td><strong>核心方法</strong>。用于触发更新流程，并会级联触发 <code>markNeedsLayout</code>。对 <code>StatefulWidget</code> 通常应使用 <code>setState</code> 触发更新。</td></tr></tbody></table><h4 id="api-详解-didupdatewidget" tabindex="-1">API 详解: <code>didUpdateWidget</code> <a class="header-anchor" href="#api-详解-didupdatewidget" aria-label="Permalink to &quot;API 详解: `didUpdateWidget`&quot;">​</a></h4>',9)),d(o,{"code-base64":"LyoqCiAqIOW9k+e7hOS7tumFjee9ruWPkeeUn+WPmOWMluaXtuiwg+eUqAogKiBAcGFyYW0gb2xkUHJvcHMg5pen55qE57uE5Lu25bGe5oCnCiAqLwpwcm90ZWN0ZWQgZGlkVXBkYXRlV2lkZ2V0KG9sZFByb3BzOiBURGF0YSk6IHZvaWQK",lang:"typescript",meta:""}),t[2]||(t[2]=e("<ul><li><strong>触发条件</strong>: 同一节点（type 匹配且 key 匹配，或无 key 且可复用）收到新 Props 时触发。</li><li><strong>执行时机</strong>: <code>Widget.createElement</code> 更新完 <code>props/data</code> 后调用；对于 <code>StatefulWidget</code>，会在 <code>render</code> 编译子树之前先调用一次，便于先同步 <code>state</code> 再渲染。</li><li><strong>典型场景</strong>: <ul><li><strong>State 同步</strong>: 当外部 Props 变化时（如 <code>value</code>），更新内部 State。</li><li><strong>副作用重置</strong>: 比如重置动画控制器、定时器或滚动位置。</li><li><strong>性能优化</strong>: 比较 Props 决定是否需要发起昂贵的计算或网络请求。</li></ul></li></ul><p><strong>示例</strong>：</p>",2)),d(o,{"code-base64":"Y2xhc3MgTXlJbnB1dCBleHRlbmRzIFN0YXRlZnVsV2lkZ2V0PE15UHJvcHMsIE15U3RhdGU+IHsKICBwcm90ZWN0ZWQgZGlkVXBkYXRlV2lkZ2V0KG9sZFByb3BzOiBNeVByb3BzKSB7CiAgICAvLyDlj6rmnInlvZMgdmFsdWUg55yf5q2j5pS55Y+Y5pe25omN5pu05pawIHN0YXRlCiAgICBpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gb2xkUHJvcHMudmFsdWUpIHsKICAgICAgdGhpcy5zZXRTdGF0ZSh7CiAgICAgICAgdmFsdWU6IHRoaXMucHJvcHMudmFsdWUsCiAgICAgIH0pOwogICAgfQogICAgc3VwZXIuZGlkVXBkYXRlV2lkZ2V0KG9sZFByb3BzKTsKICB9Cn0K",lang:"typescript",meta:""}),t[3]||(t[3]=a("h4",{id:"api-详解-markdirty",tabindex:"-1"},[c("API 详解: "),a("code",null,"markDirty"),c(),a("a",{class:"header-anchor",href:"#api-详解-markdirty","aria-label":'Permalink to "API 详解: `markDirty`"'},"​")],-1)),d(o,{"code-base64":"LyoqCiAqIOagh+iusOe7hOS7tuS4uiLohI8i54q25oCB77yM6K+35rGC6YeN5paw5p6E5bu6CiAqIOinpuWPkei3r+W+hO+8mm1hcmtEaXJ0eSAtPiBzY2hlZHVsZVVwZGF0ZSAtPiByZWJ1aWxkIC0+IGxheW91dCAtPiBwYWludAogKi8KcHVibGljIG1hcmtEaXJ0eSgpOiB2b2lkCg==",lang:"typescript",meta:""}),t[4]||(t[4]=e('<ul><li><strong>触发条件</strong>: 状态改变，需要重新运行子树计算与重建逻辑（<code>computeNextChildrenData</code> / 复合组件的 <code>render()</code> 编译）。</li><li><strong>执行流程</strong>: <ol><li>设置 <code>_dirty = true</code>。</li><li>调用 <code>runtime.scheduleUpdate(this)</code> 将自身加入 Runtime 的全局脏节点列表。</li><li>自动调用 <code>markNeedsLayout()</code>，确保更新后的结构能被正确布局。</li></ol></li></ul><h3 id="_3-layout-布局" tabindex="-1">3. Layout (布局) <a class="header-anchor" href="#_3-layout-布局" aria-label="Permalink to &quot;3. Layout (布局)&quot;">​</a></h3><p>计算组件及其子组件的尺寸和位置。Inkwell 采用单次遍历的约束传递布局模型（Constraints Down, Sizes Up）。</p><table tabindex="0"><thead><tr><th>方法</th><th>描述</th><th>典型用途</th></tr></thead><tbody><tr><td><code>markNeedsLayout</code></td><td>标记脏布局</td><td><strong>核心方法</strong>。通知框架当前节点布局失效。会自动向上寻找最近的<strong>重布局边界 (Relayout Boundary)</strong>，从而避免全树重新布局。</td></tr><tr><td><code>layout</code></td><td>布局入口</td><td>基类统一入口：缓存约束、布局子节点、调用 <code>performLayout</code>、再定位子节点</td></tr><tr><td><code>performLayout</code></td><td>执行布局计算</td><td>子类覆写：接收父级约束与子节点尺寸，返回自身 <code>Size</code></td></tr><tr><td><code>getConstraintsForChild</code></td><td>子节点约束</td><td>子类可覆写：为不同子节点生成不同约束</td></tr><tr><td><code>positionChild</code></td><td>子节点定位</td><td>子类可覆写：在自身尺寸确定后为子节点计算 <code>Offset</code></td></tr></tbody></table><h4 id="api-详解-markneedslayout" tabindex="-1">API 详解: <code>markNeedsLayout</code> <a class="header-anchor" href="#api-详解-markneedslayout" aria-label="Permalink to &quot;API 详解: `markNeedsLayout`&quot;">​</a></h4>',5)),d(o,{"code-base64":"LyoqCiAqIOagh+iusOW4g+WxgOWkseaViAogKiDop6blj5Hot6/lvoTvvJptYXJrTmVlZHNMYXlvdXQgLT4gKHVwd2FyZHMgdG8gUmVsYXlvdXRCb3VuZGFyeSkgLT4gc2NoZWR1bGVMYXlvdXQgLT4gZmx1c2hMYXlvdXQKICovCnB1YmxpYyBtYXJrTmVlZHNMYXlvdXQoKTogdm9pZAo=",lang:"typescript",meta:""}),t[5]||(t[5]=e('<ul><li><strong>触发条件</strong>: 修改了 <code>width</code>, <code>height</code>, <code>flex</code>, <code>padding</code> 等影响几何属性的值。</li><li><strong>优化机制</strong>: <ul><li>如果当前节点是 <strong>Relayout Boundary</strong>（如根节点或大小固定的节点），则停止向上传播，直接调度自身布局。</li><li>否则，递归调用 <code>parent.markNeedsLayout()</code>。</li></ul></li></ul><h3 id="_4-paint-绘制" tabindex="-1">4. Paint (绘制) <a class="header-anchor" href="#_4-paint-绘制" aria-label="Permalink to &quot;4. Paint (绘制)&quot;">​</a></h3><p>将组件内容绘制到 Canvas 上。</p><table tabindex="0"><thead><tr><th>方法</th><th>描述</th><th>典型用途</th></tr></thead><tbody><tr><td><code>markNeedsPaint</code></td><td>标记脏绘制</td><td><strong>核心方法</strong>。通知框架当前节点外观已改变。会自动向上寻找最近的<strong>重绘边界 (Repaint Boundary)</strong>，实现局部重绘。</td></tr><tr><td><code>paint</code></td><td>绘制入口</td><td>处理变换矩阵 (Transform)，保存/恢复 Canvas 上下文</td></tr><tr><td><code>paintSelf</code></td><td>绘制自身内容</td><td><strong>核心方法</strong>。使用 <code>context.renderer</code> 绘制形状、文本、图片等</td></tr><tr><td><code>isRepaintBoundary</code></td><td>重绘边界属性</td><td><strong>核心属性</strong>。设置为 <code>true</code> 时，该组件及其子树将形成独立的绘制层。子组件重绘不会污染父组件，父组件重绘也不必重绘子组件。</td></tr><tr><td><code>updateLayer</code></td><td>更新渲染层</td><td>当 <code>isRepaintBoundary</code> 为 true 时，用于管理缓存的 Layer 对象。</td></tr></tbody></table><h4 id="api-详解-markneedspaint" tabindex="-1">API 详解: <code>markNeedsPaint</code> <a class="header-anchor" href="#api-详解-markneedspaint" aria-label="Permalink to &quot;API 详解: `markNeedsPaint`&quot;">​</a></h4>',5)),d(o,{"code-base64":"LyoqCiAqIOagh+iusOe7mOWItuWkseaViAogKiDop6blj5Hot6/lvoTvvJptYXJrTmVlZHNQYWludCAtPiAodXB3YXJkcyB0byBSZXBhaW50Qm91bmRhcnkpIC0+IHNjaGVkdWxlUGFpbnQgLT4gZmx1c2hQYWludAogKi8KcHVibGljIG1hcmtOZWVkc1BhaW50KCk6IHZvaWQK",lang:"typescript",meta:""}),t[6]||(t[6]=e('<ul><li><strong>触发条件</strong>: 修改了 <code>color</code>, <code>opacity</code> 等仅影响外观的属性。</li><li><strong>优化机制</strong>: <ul><li>向上查找最近的 <code>isRepaintBoundary = true</code> 的节点。</li><li>仅重绘该边界内的内容，边界外的父节点只需合成缓存的 Layer。</li></ul></li></ul><h3 id="_5-unmount-卸载" tabindex="-1">5. Unmount (卸载) <a class="header-anchor" href="#_5-unmount-卸载" aria-label="Permalink to &quot;5. Unmount (卸载)&quot;">​</a></h3><p>组件从树中移除。</p><table tabindex="0"><thead><tr><th>方法</th><th>描述</th><th>典型用途</th></tr></thead><tbody><tr><td><code>dispose</code></td><td>销毁与清理</td><td>清理定时器、取消全局事件订阅、释放资源</td></tr></tbody></table><h2 id="状态更新机制" tabindex="-1">状态更新机制 <a class="header-anchor" href="#状态更新机制" aria-label="Permalink to &quot;状态更新机制&quot;">​</a></h2><h3 id="setstate" tabindex="-1">setState <a class="header-anchor" href="#setstate" aria-label="Permalink to &quot;setState&quot;">​</a></h3><p><code>StatefulWidget</code> 通过 <code>setState</code> 方法触发更新：</p><ol><li>合并新旧 State。</li><li>调用 <code>markDirty()</code> 标记当前节点为脏节点。</li><li>调度器 (Runtime) 在下一帧触发 <code>rebuild</code>。</li><li>触发 <code>rebuild</code>（编译/复用子树）-&gt; <code>Layout</code> -&gt; <code>Paint</code> 流程。</li></ol>',8)),d(o,{"code-base64":"dGhpcy5zZXRTdGF0ZSh7IGNvdW50OiB0aGlzLnN0YXRlLmNvdW50ICsgMSB9KTsK",lang:"typescript",meta:""}),t[7]||(t[7]=e('<h3 id="markneedslayout" tabindex="-1">markNeedsLayout <a class="header-anchor" href="#markneedslayout" aria-label="Permalink to &quot;markNeedsLayout&quot;">​</a></h3><p>当仅涉及尺寸改变而不涉及结构变化时（例如 ScrollView 滚动），可直接调用 <code>markNeedsLayout</code>：</p><ol><li>标记自身及所有父节点为 <code>_needsLayout</code>。</li><li>调度器在下一帧仅触发 Layout 和 Paint 阶段，跳过 Build 阶段，提升性能。</li></ol><h2 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to &quot;最佳实践&quot;">​</a></h2><ol><li><strong>避免在子树计算阶段执行耗时操作</strong>：<code>rebuild</code> 可能会频繁触发，应保持纯净和快速，避免分配大量临时对象。</li><li><strong>避免在 <code>render</code> 中执行耗时操作</strong>：<code>render()</code> 可能会频繁执行，应保持纯净与快速，避免分配大量临时对象。</li><li><strong>合理使用 <code>paintSelf</code></strong>：仅在需要自定义绘制（如绘制图表、特殊形状）时实现 <code>paintSelf</code>，普通 UI 组合优先使用 <code>StatelessWidget/StatefulWidget</code> 的声明式 <code>render()</code>。</li><li><strong>Layout 边界</strong>：如果你实现了一个自定义 Layout 组件，确保正确处理 <code>BoxConstraints</code>，特别是无界约束 (Unbounded Constraints)。</li><li><strong>及时清理</strong>：在 <code>dispose</code> 中务必清理手动添加的全局监听器或定时器，防止内存泄漏。</li></ol>',5))])}i(m,"_sfc_render");const W=g(h,[["render",m]]);export{k as __pageData,W as default};
