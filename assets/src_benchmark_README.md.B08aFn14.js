import{_ as n,C as a,c as d,o,ai as e,G as r}from"./chunks/framework.Ckc8SVM3.js";const m=JSON.parse('{"title":"Inkwell Benchmark Guidelines","description":"","frontmatter":{},"headers":[],"relativePath":"src/benchmark/README.md","filePath":"src/benchmark/README.md"}'),i={name:"src/benchmark/README.md"};function s(g,t,c,h,f,x){const l=a("InkCodeBlock");return o(),d("div",null,[t[0]||(t[0]=e('<h1 id="inkwell-benchmark-guidelines" tabindex="-1">Inkwell Benchmark Guidelines <a class="header-anchor" href="#inkwell-benchmark-guidelines" aria-label="Permalink to &quot;Inkwell Benchmark Guidelines&quot;">​</a></h1><p>本文档旨在规范 Inkwell 框架的性能基准测试流程，确保 Widget 渲染性能持续优于原生 DOM。</p><h2 id="_1-性能优化规则" tabindex="-1">1. 性能优化规则 <a class="header-anchor" href="#_1-性能优化规则" aria-label="Permalink to &quot;1. 性能优化规则&quot;">​</a></h2><p>我们重点优化 <code>src/runtime</code> 和 <code>src/core</code> 中的通用生命周期方法。以下是核心方法的性能监控列表，按耗时从高到低排序（优化优先级递减）：</p><table tabindex="0"><thead><tr><th style="text-align:left;">优先级</th><th style="text-align:left;">核心方法</th><th style="text-align:left;">典型耗时 (ms)</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>P0</strong></td><td style="text-align:left;"><code>Canvas2DRenderer.paint</code></td><td style="text-align:left;"><em>待测</em></td><td style="text-align:left;">实际的 Canvas 绘制指令执行</td></tr><tr><td style="text-align:left;"><strong>P0</strong></td><td style="text-align:left;"><code>PipelineOwner.flushLayout</code></td><td style="text-align:left;"><em>待测</em></td><td style="text-align:left;">布局计算阶段（含 <code>performLayout</code>）</td></tr><tr><td style="text-align:left;"><strong>P1</strong></td><td style="text-align:left;"><code>PipelineOwner.flushPaint</code></td><td style="text-align:left;"><em>待测</em></td><td style="text-align:left;">绘制遍历阶段（含 Layer 合成）</td></tr><tr><td style="text-align:left;"><strong>P1</strong></td><td style="text-align:left;"><code>Widget.build</code> / <code>rebuild</code></td><td style="text-align:left;"><em>待测</em></td><td style="text-align:left;">Widget 树的构建与 Diff</td></tr><tr><td style="text-align:left;"><strong>P2</strong></td><td style="text-align:left;"><code>Element.mount</code></td><td style="text-align:left;"><em>待测</em></td><td style="text-align:left;">元素挂载与初始化</td></tr><tr><td style="text-align:left;"><strong>P2</strong></td><td style="text-align:left;"><code>Element.update</code></td><td style="text-align:left;"><em>待测</em></td><td style="text-align:left;">属性更新与状态同步</td></tr></tbody></table><blockquote><p><strong>注</strong>：开发人员需定期运行 Profile 工具更新上述耗时数据，始终优先解决 P0 级瓶颈。</p></blockquote><h2 id="_2-优化执行流程" tabindex="-1">2. 优化执行流程 <a class="header-anchor" href="#_2-优化执行流程" aria-label="Permalink to &quot;2. 优化执行流程&quot;">​</a></h2><p>为保证优化的稳定性和可追溯性，必须严格遵守以下流程：</p><ol><li><strong>单步执行</strong>：每次只修改一个变量或优化一个具体的函数逻辑。严禁一次性提交多处无关的性能修改。</li><li><strong>基准验证</strong>： <ul><li>修改前：运行基准测试，记录基准数据（Baseline）。</li><li>修改后：再次运行同一测试。</li></ul></li><li><strong>决策机制</strong>： <ul><li><strong>有效</strong>（耗时减少 &gt; 5% 且无回归）：<strong>采纳</strong>代码并提交。</li><li><strong>无效</strong>（耗时不变或增加）：<strong>回滚</strong>更改，分析原因。</li><li><strong>回归</strong>（功能破坏）：<strong>立即回滚</strong>。</li></ul></li><li><strong>持续迭代</strong>：在解决当前瓶颈后，重新评估方法耗时排序，进入下一轮优化。</li></ol><h2 id="_3-性能标准" tabindex="-1">3. 性能标准 <a class="header-anchor" href="#_3-性能标准" aria-label="Permalink to &quot;3. 性能标准&quot;">​</a></h2><p>所有基准测试必须满足以下核心指标，否则视为<strong>未达标</strong>：</p><ul><li><strong>Widget vs DOM</strong>: Inkwell Widget 实现的渲染与交互性能必须 <strong>优于 (&lt;)</strong> 原生 DOM 实现。</li><li><strong>Frame Budget</strong>: 动画/滚动场景下，单帧处理时间 &lt; <strong>16ms</strong> (60 FPS)。</li><li><strong>Test Duration</strong>: 单个 benchmark 测试用例执行时间 &lt; <strong>1s</strong>。</li></ul><h2 id="_4-优化记录" tabindex="-1">4. 优化记录 <a class="header-anchor" href="#_4-优化记录" aria-label="Permalink to &quot;4. 优化记录&quot;">​</a></h2><p>记录每次优化的关键数据，用于长期跟踪性能趋势。</p><table tabindex="0"><thead><tr><th style="text-align:left;">日期</th><th style="text-align:left;">优化内容</th><th style="text-align:left;">目标方法</th><th style="text-align:left;">优化前耗时</th><th style="text-align:left;">优化后耗时</th><th style="text-align:left;">提升比例</th><th style="text-align:left;">状态</th></tr></thead><tbody><tr><td style="text-align:left;">2024-01-11</td><td style="text-align:left;">减少 <code>dom.spec.ts</code> 节点规模</td><td style="text-align:left;">Test Case</td><td style="text-align:left;">48,108ms</td><td style="text-align:left;">1,551ms</td><td style="text-align:left;">96.7%</td><td style="text-align:left;">✅ 采纳</td></tr><tr><td style="text-align:left;">2024-01-11</td><td style="text-align:left;">优化 <code>pipeline.spec.ts</code> 帧数</td><td style="text-align:left;">Test Case</td><td style="text-align:left;">1,931ms</td><td style="text-align:left;">&lt; 1,000ms</td><td style="text-align:left;">&gt; 48%</td><td style="text-align:left;">✅ 采纳</td></tr><tr><td style="text-align:left;">2026-01-12</td><td style="text-align:left;">核心渲染管线与组件优化</td><td style="text-align:left;">Pipeline Widget</td><td style="text-align:left;">14 FPS</td><td style="text-align:left;">386 FPS</td><td style="text-align:left;">27.6x</td><td style="text-align:left;">✅ 采纳</td></tr><tr><td style="text-align:left;">2026-01-12</td><td style="text-align:left;">状态更新机制优化</td><td style="text-align:left;">State Widget</td><td style="text-align:left;">104 FPS</td><td style="text-align:left;">941 FPS</td><td style="text-align:left;">9.0x</td><td style="text-align:left;">✅ 采纳</td></tr></tbody></table><h2 id="_5-核心优化经验-2026-01-12-更新" tabindex="-1">5. 核心优化经验 (2026-01-12 更新) <a class="header-anchor" href="#_5-核心优化经验-2026-01-12-更新" aria-label="Permalink to &quot;5. 核心优化经验 (2026-01-12 更新)&quot;">​</a></h2><p>基于最近的大规模优化实践，我们总结了以下提升 InkWell 性能的关键策略：</p><h3 id="_5-1-运行时与管线-runtime-pipeline" tabindex="-1">5.1 运行时与管线 (Runtime &amp; Pipeline) <a class="header-anchor" href="#_5-1-运行时与管线-runtime-pipeline" aria-label="Permalink to &quot;5.1 运行时与管线 (Runtime &amp; Pipeline)&quot;">​</a></h3><ul><li><strong>减少全量遍历</strong>：在手动触发布局后，及时清理待处理队列 (<code>clearNodesNeedingLayout</code>)，避免后续阶段的无效遍历。</li><li><strong>智能根节点复用</strong>：在 <code>renderFromJSON</code> 中检测根节点类型，支持局部更新而非盲目全量重建，特别是对于尺寸未变的场景。</li></ul><h3 id="_5-2-组件层级-core-widgets" tabindex="-1">5.2 组件层级 (Core Widgets) <a class="header-anchor" href="#_5-2-组件层级-core-widgets" aria-label="Permalink to &quot;5.2 组件层级 (Core Widgets)&quot;">​</a></h3><ul><li><strong>事件绑定快速路径</strong>：利用编译器注入的 <code>__noEvents</code> 标记，对绝大多数无交互的展示型组件跳过事件绑定逻辑 (<code>DOMEventManager</code>)，大幅降低构建开销。</li><li><strong>绘制指令优化</strong>：在 <code>_performPaint</code> 中为纯平移变换 (<code>translate</code>) 提供快速路径，避开昂贵的矩阵运算。</li><li><strong>布局对象池化</strong>：在 <code>Stack</code> 和 <code>Positioned</code> 中内联定位逻辑，移除临时对象 (<code>Offset</code>) 分配；在 <code>Container</code> 中复用 <code>EdgeInsets</code> 和 <code>BorderRadius</code> 对象。</li></ul><h3 id="_5-3-渲染层级-renderer" tabindex="-1">5.3 渲染层级 (Renderer) <a class="header-anchor" href="#_5-3-渲染层级-renderer" aria-label="Permalink to &quot;5.3 渲染层级 (Renderer)&quot;">​</a></h3><ul><li><strong>Native API 优先</strong>：使用 <code>roundRect</code> 替代手动的 <code>arc</code> 路径绘制。</li><li><strong>状态缓存</strong>：在 Renderer 内部缓存 Context 状态 (fillStyle, lineWidth 等)，减少 DOM 属性赋值带来的性能损耗。</li><li><strong>编译期优化</strong>：通过 <code>JSX Compiler</code> 预处理事件监听器，将运行时开销转移至编译期。</li></ul><h2 id="_6-基准测试指南" tabindex="-1">6. 基准测试指南 <a class="header-anchor" href="#_6-基准测试指南" aria-label="Permalink to &quot;6. 基准测试指南&quot;">​</a></h2><h3 id="运行测试" tabindex="-1">运行测试 <a class="header-anchor" href="#运行测试" aria-label="Permalink to &quot;运行测试&quot;">​</a></h3>',25)),r(l,{"code-base64":"IyDov5DooYzmiYDmnInln7rlh4bmtYvor5UKcG5wbSBydW4gdGVzdDpiZW5jaG1hcmsKCiMg6L+Q6KGM54m55a6a5rWL6K+VICjlpoIgRE9NIOaMh+aghykKbnB4IHZpdGVzdCBydW4gc3JjL2JlbmNobWFyay9tZXRyaWNzL19fdGVzdHNfXy9kb20uc3BlYy50cwo=",lang:"bash",meta:""}),t[1]||(t[1]=e('<h3 id="验证对齐" tabindex="-1">验证对齐 <a class="header-anchor" href="#验证对齐" aria-label="Permalink to &quot;验证对齐&quot;">​</a></h3><p>在运行性能对比前，必须确保 Widget 实现与 DOM 实现 <strong>像素级对齐 (Pixel-Perfect)</strong>：</p><ul><li><strong>尺寸</strong>: 宽高、边距、内边距完全一致。</li><li><strong>样式</strong>: 颜色、字体、边框无肉眼可见差异。</li><li><strong>布局</strong>: 确保 Flex 布局行为一致。</li></ul>',3))])}const u=n(i,[["render",s]]);export{m as __pageData,u as default};
