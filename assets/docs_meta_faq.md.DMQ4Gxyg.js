var n=Object.defineProperty;var l=(o,a)=>n(o,"name",{value:a,configurable:!0});import{$ as d,a5 as i,S as s,V as c,ag as e,a6 as r}from"./chunks/plugin-vue_export-helper.hykleeSY.js";const P=JSON.parse('{"title":"常见问题","description":"","frontmatter":{"id":"faq","title":"常见问题","sidebar_position":1},"headers":[],"relativePath":"docs/meta/faq.md","filePath":"docs/meta/faq.md"}'),h={name:"docs/meta/faq.md"};function q(o,a,u,g,b,p){const t=i("InkCodeBlock");return c(),s("div",null,[a[0]||(a[0]=e('<h1 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h1><p>本文档汇总了在使用 Inkwell 框架开发过程中可能遇到的典型问题及解决方案。</p><h2 id="概念与原理" tabindex="-1">概念与原理 <a class="header-anchor" href="#概念与原理" aria-label="Permalink to &quot;概念与原理&quot;">​</a></h2><h3 id="q-inkwell-与-react-dom-有什么区别" tabindex="-1">Q: Inkwell 与 React DOM 有什么区别？ <a class="header-anchor" href="#q-inkwell-与-react-dom-有什么区别" aria-label="Permalink to &quot;Q: Inkwell 与 React DOM 有什么区别？&quot;">​</a></h3><p><strong>A</strong>: Inkwell 是一个 Canvas 渲染引擎，它使用 React 作为 DSL (领域特定语言) 来描述 UI，但不使用 React DOM 或 HTML 元素。这使得它在处理大量图形节点（如思维导图、图表）时具有更高的性能。</p><h3 id="q-支持-css-吗" tabindex="-1">Q: 支持 CSS 吗？ <a class="header-anchor" href="#q-支持-css-吗" aria-label="Permalink to &quot;Q: 支持 CSS 吗？&quot;">​</a></h3><p><strong>A</strong>: 不支持传统的 CSS。Inkwell 使用类似 Flutter 的样式对象和 Flex 布局模型。</p><h3 id="q-如何处理文本渲染" tabindex="-1">Q: 如何处理文本渲染？ <a class="header-anchor" href="#q-如何处理文本渲染" aria-label="Permalink to &quot;Q: 如何处理文本渲染？&quot;">​</a></h3><p><strong>A</strong>: Inkwell 内部实现了轻量级的文本布局引擎，支持基本的换行和对齐。</p><h2 id="基础使用" tabindex="-1">基础使用 <a class="header-anchor" href="#基础使用" aria-label="Permalink to &quot;基础使用&quot;">​</a></h2><h3 id="q-为什么我的组件没有显示" tabindex="-1">Q: 为什么我的组件没有显示？ <a class="header-anchor" href="#q-为什么我的组件没有显示" aria-label="Permalink to &quot;Q: 为什么我的组件没有显示？&quot;">​</a></h3><p><strong>A</strong>: 请检查以下几点：</p><ol><li><strong>尺寸约束</strong>：父组件是否提供了有效的尺寸约束？如果父组件是 <code>unbounded</code>（如 <code>Row</code> 的水平方向），子组件必须有明确宽度。</li><li><strong>绘制方法</strong>：如果是自定义 Widget，确保 <code>paintSelf/performLayout</code> 等核心方法已按契约实现。</li><li><strong>层级关系</strong>：检查 <code>z-index</code> 或绘制顺序，可能被其他组件覆盖。</li></ol><h3 id="q-如何给组件添加点击事件" tabindex="-1">Q: 如何给组件添加点击事件？ <a class="header-anchor" href="#q-如何给组件添加点击事件" aria-label="Permalink to &quot;Q: 如何给组件添加点击事件？&quot;">​</a></h3>',14)),r(t,{"code-base64":"ICA8Q29udGFpbmVyIGNvbG9yPSJibHVlIiB3aWR0aD17MTAwfSBoZWlnaHQ9ezEwMH0gb25DbGljaz17KCkgPT4gY29uc29sZS5sb2coJ+eCueWHuyBDb250YWluZXInKX0gLz4K",lang:"tsx",meta:""}),a[1]||(a[1]=e('<p>注意：组件需要具备有效的布局尺寸（<code>width/height</code> 或可推导出的 size），并处于可命中的区域内；事件会通过命中测试找到目标节点并按捕获/冒泡阶段分发。</p><h2 id="布局与样式" tabindex="-1">布局与样式 <a class="header-anchor" href="#布局与样式" aria-label="Permalink to &quot;布局与样式&quot;">​</a></h2><h3 id="q-row-或-column-内容溢出怎么办" tabindex="-1">Q: <code>Row</code> 或 <code>Column</code> 内容溢出怎么办？ <a class="header-anchor" href="#q-row-或-column-内容溢出怎么办" aria-label="Permalink to &quot;Q: `Row` 或 `Column` 内容溢出怎么办？&quot;">​</a></h3><p><strong>A</strong>:</p><ol><li>使用 <code>Expanded</code> 包裹子组件，使其按 <code>flex</code> 分配剩余空间（必要时给子组件明确尺寸）。</li><li>如果内容确实超出屏幕，考虑使用 <code>ScrollView</code> 包裹内容区域。</li></ol><h3 id="q-如何实现绝对定位" tabindex="-1">Q: 如何实现绝对定位？ <a class="header-anchor" href="#q-如何实现绝对定位" aria-label="Permalink to &quot;Q: 如何实现绝对定位？&quot;">​</a></h3><p><strong>A</strong>: 使用 <code>Stack</code> + <code>Positioned</code> 组合：</p>',7)),r(t,{"code-base64":"PFN0YWNrPgogIDxDb250YWluZXIgd2lkdGg9ezIwMH0gaGVpZ2h0PXsyMDB9IGNvbG9yPSJyZWQiIC8+CiAgPFBvc2l0aW9uZWQgbGVmdD17MTB9IHRvcD17MTB9PgogICAgPFRleHQgdGV4dD0iT3ZlcmxheSIgLz4KICA8L1Bvc2l0aW9uZWQ+CjwvU3RhY2s+Cg==",lang:"tsx",meta:""}),a[2]||(a[2]=e('<h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><h3 id="q-界面卡顿如何排查" tabindex="-1">Q: 界面卡顿如何排查？ <a class="header-anchor" href="#q-界面卡顿如何排查" aria-label="Permalink to &quot;Q: 界面卡顿如何排查？&quot;">​</a></h3><p><strong>A</strong>:</p><ol><li><strong>减少重绘</strong>：避免在 <code>paint</code> 方法中创建新对象（如 <code>Paint</code>、<code>Path</code>）。</li><li><strong>局部更新</strong>：使用 <code>RepaintBoundary</code> 隔离频繁变化的区域。</li><li><strong>DevTools</strong>：使用 Inkwell DevTools 查看渲染树和重绘区域。</li></ol><h3 id="q-为什么-setstate-后没有更新" tabindex="-1">Q: 为什么 <code>setState</code> 后没有更新？ <a class="header-anchor" href="#q-为什么-setstate-后没有更新" aria-label="Permalink to &quot;Q: 为什么 `setState` 后没有更新？&quot;">​</a></h3><p><strong>A</strong>:</p><ol><li>检查 <code>setState</code> 是否在组件挂载（Mounted）后调用。</li><li>确认修改的状态变量是否真的发生了变化（浅比较）。</li><li>如果是引用类型（对象/数组），请确保创建了新引用而不是修改原对象。</li></ol><h2 id="调试" tabindex="-1">调试 <a class="header-anchor" href="#调试" aria-label="Permalink to &quot;调试&quot;">​</a></h2><h3 id="q-如何查看组件树结构" tabindex="-1">Q: 如何查看组件树结构？ <a class="header-anchor" href="#q-如何查看组件树结构" aria-label="Permalink to &quot;Q: 如何查看组件树结构？&quot;">​</a></h3><p><strong>A</strong>:</p><ol><li>使用 Inkwell DevTools (参阅 <a href="./../advanced/devtools">开发者工具</a>)。</li></ol>',11))])}l(q,"_sfc_render");const k=d(h,[["render",q]]);export{P as __pageData,k as default};
