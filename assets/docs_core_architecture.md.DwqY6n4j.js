var r=Object.defineProperty;var a=(d,e)=>r(d,"name",{value:e,configurable:!0});import{$ as n,a5 as i,S as g,V as s,ag as t,a6 as l}from"./chunks/plugin-vue_export-helper.hykleeSY.js";const Z=JSON.parse('{"title":"架构设计","description":"","frontmatter":{"id":"architecture","title":"架构设计","sidebar_position":1},"headers":[],"relativePath":"docs/core/architecture.md","filePath":"docs/core/architecture.md"}'),I={name:"docs/core/architecture.md"};function C(d,e,u,W,h,b){const c=i("InkMermaidBlock"),o=i("InkCodeBlock");return s(),g("div",null,[e[0]||(e[0]=t('<h1 id="架构设计" tabindex="-1">架构设计 <a class="header-anchor" href="#架构设计" aria-label="Permalink to &quot;架构设计&quot;">​</a></h1><p>本文档详细描述 Inkwell 框架的架构设计、模块划分及运行时机制。</p><h2 id="_1-核心架构图" tabindex="-1">1. 核心架构图 <a class="header-anchor" href="#_1-核心架构图" aria-label="Permalink to &quot;1. 核心架构图&quot;">​</a></h2><p>Inkwell 采用分层架构设计，自底向上分为：<strong>渲染层</strong>、<strong>运行时层</strong>、<strong>核心框架层</strong>和<strong>应用层</strong>。</p>',4)),l(c,{"code-base64":"Z3JhcGggVEQKICAgIEFwcGxpY2F0aW9uTGF5ZXJbIuW6lOeUqOWxgiAoc3JjL2RlbW8pIl0KICAgIEZyYW1ld29ya0xheWVyWyLmoLjlv4PmoYbmnrblsYIgKHNyYy9jb3JlKSJdCiAgICBSdW50aW1lTGF5ZXJbIui/kOihjOaXtuWxgiAoc3JjL3J1bnRpbWUpIl0KICAgIFV0aWxzTGF5ZXJbIuW3peWFt+WxgiAoc3JjL3V0aWxzKSJdCiAgICBSZW5kZXJlckxheWVyWyLmuLLmn5PlsYIgKHNyYy9yZW5kZXJlcikiXQoKICAgIHN1YmdyYXBoIGFwcFsi5bqU55So5bGCIChzcmMvZGVtbykiXQogICAgICAgIE1pbmRtYXBbIuaAnee7tOWvvOWbviAobWluZG1hcCkiXQogICAgICAgIFNwcmVhZHNoZWV0WyLnlLXlrZDooajmoLwgKHNwcmVhZHNoZWV0KSJdCiAgICAgICAgV2lraVsiV2lraSAod2lraSkiXQogICAgICAgIFdpZGdldEdhbGxlcnlbIumDqOS7tueUu+W7iiAod2lkZ2V0LWdhbGxlcnkpIl0KICAgICAgICBDb21wR2FsbGVyeVsi57uE5Lu255S75buKIChjb21wLWdhbGxlcnkpIl0KICAgIGVuZAoKICAgIHN1YmdyYXBoIGZyYW1ld29ya1si5qC45b+D5qGG5p625bGCIChzcmMvY29yZSkiXQogICAgICAgIFdpZGdldFsiV2lkZ2V0IFN5c3RlbSJdCiAgICAgICAgRXZlbnRzWyJFdmVudCBTeXN0ZW0iXQogICAgICAgIFBpcGVsaW5lWyJQaXBlbGluZSBPd25lciJdCiAgICAgICAgQmFzZVsiQmFzZSBEZWZpbml0aW9ucyJdCiAgICBlbmQKCiAgICBzdWJncmFwaCBydW50aW1lWyLov5DooYzml7blsYIgKHNyYy9ydW50aW1lKSJdCiAgICAgICAgUlRbIlJ1bnRpbWUgRW5naW5lIl0KICAgICAgICBTY2hlZHVsZXJbIlNjaGVkdWxlciAvIFRpY2siXQogICAgICAgIENvbXBvbmVudERhdGFbIkNvbXBvbmVudERhdGEiXQogICAgZW5kCgogICAgc3ViZ3JhcGggdXRpbHNbIuW3peWFt+WxgiAoc3JjL3V0aWxzKSJdCiAgICAgICAgQ29tcGlsZXJbIkpTWCBDb21waWxlciJdCiAgICBlbmQKCiAgICBzdWJncmFwaCByZW5kZXJlclsi5riy5p+T5bGCIChzcmMvcmVuZGVyZXIpIl0KICAgICAgICBDYW52YXMyRFsiQ2FudmFzMkQgUmVuZGVyZXIiXQogICAgICAgIElSZW5kZXJlclsiSVJlbmRlcmVyIEludGVyZmFjZSJdCiAgICBlbmQKCiAgICBBcHBsaWNhdGlvbkxheWVyIC0tPnzljIXlkKt8IE1pbmRtYXAKICAgIEFwcGxpY2F0aW9uTGF5ZXIgLS0+fOWMheWQq3wgU3ByZWFkc2hlZXQKICAgIEFwcGxpY2F0aW9uTGF5ZXIgLS0+fOWMheWQq3wgV2lraQogICAgQXBwbGljYXRpb25MYXllciAtLT585YyF5ZCrfCBXaWRnZXRHYWxsZXJ5CiAgICBBcHBsaWNhdGlvbkxheWVyIC0tPnzljIXlkKt8IENvbXBHYWxsZXJ5CgogICAgRnJhbWV3b3JrTGF5ZXIgLS0+fOWMheWQq3wgV2lkZ2V0CiAgICBGcmFtZXdvcmtMYXllciAtLT585YyF5ZCrfCBFdmVudHMKICAgIEZyYW1ld29ya0xheWVyIC0tPnzljIXlkKt8IFBpcGVsaW5lCiAgICBGcmFtZXdvcmtMYXllciAtLT585YyF5ZCrfCBCYXNlCgogICAgUnVudGltZUxheWVyIC0tPnzljIXlkKt8IFJUCiAgICBSdW50aW1lTGF5ZXIgLS0+fOWMheWQq3wgU2NoZWR1bGVyCiAgICBSdW50aW1lTGF5ZXIgLS0+fOWMheWQq3wgQ29tcG9uZW50RGF0YQoKICAgIFV0aWxzTGF5ZXIgLS0+fOWMheWQq3wgQ29tcGlsZXIKCiAgICBSZW5kZXJlckxheWVyIC0tPnzljIXlkKt8IENhbnZhczJECiAgICBSZW5kZXJlckxheWVyIC0tPnzljIXlkKt8IElSZW5kZXJlcgoKICAgIEFwcGxpY2F0aW9uTGF5ZXIgLS0+fEpTWHwgQ29tcGlsZXIKICAgIENvbXBpbGVyIC0tPnxKU09OfCBSdW50aW1lTGF5ZXIKICAgIFJ1bnRpbWVMYXllciAtLT58566h55CGfCBGcmFtZXdvcmtMYXllcgogICAgRnJhbWV3b3JrTGF5ZXIgLS0+fOe7mOWItnwgUmVuZGVyZXJMYXllcgogICAgUnVudGltZUxheWVyIC0tPnzmjqfliLZ8IFJlbmRlcmVyTGF5ZXIK"}),e[1]||(e[1]=t('<h2 id="_2-核心模块划分" tabindex="-1">2. 核心模块划分 <a class="header-anchor" href="#_2-核心模块划分" aria-label="Permalink to &quot;2. 核心模块划分&quot;">​</a></h2><p>参考 <code>src</code> 目录结构，主要模块如下：</p><h3 id="_2-1-runtime-运行时-src-runtime" tabindex="-1">2.1 Runtime (运行时) - <code>src/runtime</code> <a class="header-anchor" href="#_2-1-runtime-运行时-src-runtime" aria-label="Permalink to &quot;2.1 Runtime (运行时) - `src/runtime`&quot;">​</a></h3><p>整个引擎的&quot;心脏&quot;。</p><ul><li><strong>Runtime Class</strong>: 负责初始化环境、管理 Canvas 实例、持有根节点 (<code>rootWidget</code>)。</li><li><strong>Tick Loop</strong>: 通过 <code>requestAnimationFrame</code> 驱动渲染循环。</li><li><strong>Error Handling</strong>: 捕获渲染错误并以覆盖层形式展示（类似 Flutter 的红屏报错）。</li></ul><h3 id="_2-2-core-核心框架-src-core" tabindex="-1">2.2 Core (核心框架) - <code>src/core</code> <a class="header-anchor" href="#_2-2-core-核心框架-src-core" aria-label="Permalink to &quot;2.2 Core (核心框架) - `src/core`&quot;">​</a></h3><p>构建 UI 的基础构件。</p><ul><li><strong>Widget Base</strong> (<code>src/core/base.ts</code>): 定义了 <code>Widget</code> 抽象基类。 <ul><li><strong>统一树结构</strong>: Inkwell 采用单棵 Widget 树。每个 Widget 实例持有配置数据（<code>data/props</code>）、渲染对象（<code>renderObject</code>）以及布局/绘制相关的方法；有状态组件通过 <code>StatefulWidget</code> 扩展维护 <code>state</code>。</li></ul></li><li><strong>Pipeline</strong> (<code>src/core/pipeline</code>): <code>PipelineOwner</code> 负责管理布局和绘制的脏列表 (<code>_nodesNeedingLayout</code>, <code>_nodesNeedingPaint</code>)，并执行 <code>flushLayout</code> 和 <code>flushPaint</code>。</li><li><strong>Events</strong> (<code>src/core/events</code>): 实现了类似 DOM 的事件冒泡机制。<code>Dispatcher</code> 负责将原生 Canvas 事件转换为 Inkwell 事件。</li></ul><h3 id="_2-3-renderer-渲染器-src-renderer" tabindex="-1">2.3 Renderer (渲染器) - <code>src/renderer</code> <a class="header-anchor" href="#_2-3-renderer-渲染器-src-renderer" aria-label="Permalink to &quot;2.3 Renderer (渲染器) - `src/renderer`&quot;">​</a></h3><ul><li><strong>IRenderer</strong>: 定义绘制接口（如 <code>drawRect</code>, <code>drawText</code>）。</li><li><strong>Canvas2DRenderer</strong>: 基于 HTML5 Canvas 2D Context 的具体实现。支持离屏渲染优化。</li><li><strong>Layer</strong>: 渲染层对象，配合 <code>RepaintBoundary</code> 实现局部重绘缓存。</li></ul><h3 id="_2-4-compiler-编译器-src-utils-compiler" tabindex="-1">2.4 Compiler (编译器) - <code>src/utils/compiler</code> <a class="header-anchor" href="#_2-4-compiler-编译器-src-utils-compiler" aria-label="Permalink to &quot;2.4 Compiler (编译器) - `src/utils/compiler`&quot;">​</a></h3><ul><li><strong>compileElement</strong>: 在运行时将 React JSX 元素转换为轻量级的 JSON 数据 (<code>ComponentData</code>)，供 <code>Runtime</code> 消费。这使得我们可以使用 React 的语法，但不依赖 React 的 Reconciler。</li></ul><h2 id="_3-运行时机制" tabindex="-1">3. 运行时机制 <a class="header-anchor" href="#_3-运行时机制" aria-label="Permalink to &quot;3. 运行时机制&quot;">​</a></h2><p>Inkwell 的渲染流程是<strong>按需更新</strong>的。</p><h3 id="_3-1-启动流程" tabindex="-1">3.1 启动流程 <a class="header-anchor" href="#_3-1-启动流程" aria-label="Permalink to &quot;3.1 启动流程&quot;">​</a></h3><p>参考 <code>src/demo/mindmap/app.tsx</code>:</p>',16)),l(o,{"code-base64":"ZXhwb3J0IGZ1bmN0aW9uIHJ1bkFwcChydW50aW1lOiBSdW50aW1lLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQgewogIC8vIDEuIOe8luivkSBKU1gg5Li6IENvbXBvbmVudERhdGEKICAvLyAyLiBSdW50aW1lIOWIm+W7uiBXaWRnZXQg5qCRCiAgLy8gMy4g6Kem5Y+R5Yid5aeLIExheW91dCDlkowgUGFpbnQKICBydW50aW1lLnJlbmRlcig8TWluZG1hcERlbW8gd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gLz4pOwp9Cg==",lang:"typescript",meta:""}),e[2]||(e[2]=t('<h3 id="_3-2-更新循环-the-tick" tabindex="-1">3.2 更新循环 (The Tick) <a class="header-anchor" href="#_3-2-更新循环-the-tick" aria-label="Permalink to &quot;3.2 更新循环 (The Tick)&quot;">​</a></h3><p>当组件状态改变时（例如 <code>setState</code>）：</p><ol><li><strong>Mark Dirty</strong>: 调用 <code>markNeedsLayout()</code> 或 <code>markNeedsPaint()</code>。</li><li><strong>Schedule</strong>: 组件被加入 <code>PipelineOwner</code> 的脏列表中。<code>Runtime</code> 请求下一帧。</li><li><strong>Flush Layout</strong>: <ul><li><code>Runtime</code> 调用 <code>pipelineOwner.flushLayout()</code>。</li><li>按<strong>深度优先</strong>顺序遍历脏节点。</li><li>执行 <code>layout()</code> 计算尺寸（遵循 Constraints 协议）。</li></ul></li><li><strong>Flush Paint</strong>: <ul><li><code>Runtime</code> 清除画布。</li><li>从根节点开始遍历绘制（或仅重绘 <code>RepaintBoundary</code>）。</li></ul></li></ol><h3 id="_3-3-布局协议" tabindex="-1">3.3 布局协议 <a class="header-anchor" href="#_3-3-布局协议" aria-label="Permalink to &quot;3.3 布局协议&quot;">​</a></h3><p>与 Flutter 一致：</p><blockquote><p><strong>Constraints go down. Sizes go up. Parent sets position.</strong></p></blockquote>',6)),l(o,{"code-base64":"Ly8gc3JjL2NvcmUvYmFzZS50c++8iOeugOWMluWQjueahOaWueazleetvuWQje+8iQpjbGFzcyBXaWRnZXQgewogIGxheW91dChjb25zdHJhaW50czogQm94Q29uc3RyYWludHMpOiBTaXplOwogIHByb3RlY3RlZCBwZXJmb3JtTGF5b3V0KGNvbnN0cmFpbnRzOiBCb3hDb25zdHJhaW50cywgY2hpbGRyZW5TaXplczogU2l6ZVtdKTogU2l6ZTsKCiAgcGFpbnQoY29udGV4dDogQnVpbGRDb250ZXh0KTogdm9pZDsKICBwcm90ZWN0ZWQgcGFpbnRTZWxmKGNvbnRleHQ6IEJ1aWxkQ29udGV4dCk6IHZvaWQ7Cn0K",lang:"typescript",meta:""}),e[3]||(e[3]=t('<p>这里的关键点是：</p><ul><li><code>layout/paint</code> 是基类提供的统一入口；自定义 Widget 通常覆写 <code>performLayout/paintSelf</code>。</li><li>组合型组件（<code>StatelessWidget/StatefulWidget</code>）通常覆写 <code>render()</code>，由框架在 <code>rebuild</code> 时编译其子树并进入同一套 <code>layout/paint</code> 管线。</li></ul><h2 id="_4-与-flutter-的主要差异" tabindex="-1">4. 与 Flutter 的主要差异 <a class="header-anchor" href="#_4-与-flutter-的主要差异" aria-label="Permalink to &quot;4. 与 Flutter 的主要差异&quot;">​</a></h2><p>尽管设计深受 Flutter 启发，但为了适应 Web 和 JS 生态，Inkwell 做了以下权衡：</p><table tabindex="0"><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">Flutter</th><th style="text-align:left;">Inkwell</th><th style="text-align:left;">原因</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>树结构</strong></td><td style="text-align:left;"><strong>三棵树</strong> (Widget, Element, RenderObject)</td><td style="text-align:left;"><strong>单棵树</strong> (Widget 实例)</td><td style="text-align:left;">简化 JS 对象模型，减少 GC 压力；降低理解成本。</td></tr><tr><td style="text-align:left;"><strong>语言</strong></td><td style="text-align:left;">Dart</td><td style="text-align:left;">TypeScript + JSX</td><td style="text-align:left;">利用 React 生态和前端开发者的现有技能。</td></tr><tr><td style="text-align:left;"><strong>编译方式</strong></td><td style="text-align:left;">AOT / JIT</td><td style="text-align:left;">Runtime Compilation (JSX -&gt; JSON)</td><td style="text-align:left;">保持动态性，允许在浏览器中直接运行 JSX。</td></tr><tr><td style="text-align:left;"><strong>布局系统</strong></td><td style="text-align:left;">RenderBox</td><td style="text-align:left;">Widget 内置 layout 方法</td><td style="text-align:left;">由于单树结构，布局逻辑直接存在于 Widget 中。</td></tr></tbody></table><h3 id="差异详解-单树结构" tabindex="-1">差异详解：单树结构 <a class="header-anchor" href="#差异详解-单树结构" aria-label="Permalink to &quot;差异详解：单树结构&quot;">​</a></h3><p>在 Flutter 中，<code>Widget</code> 是不可变的配置，<code>Element</code> 管理生命周期，<code>RenderObject</code> 管理渲染。 在 Inkwell 中，为了减少对象创建（JS 引擎对大量短生命周期对象敏感），我们将这三者合并：</p><ul><li><code>Widget</code> 类实例是可变的（Mutable）。</li><li>它持有 <code>props</code> (Configuration)。</li><li>它持有 <code>state</code> (State management)。</li><li>它直接实现 <code>layout</code> 和 <code>paint</code> (Render logic)。</li></ul><p>这种设计使得 Inkwell 更像是一个 &quot;Stateful Render Object Tree&quot;。</p><h2 id="_5-代码示例" tabindex="-1">5. 代码示例 <a class="header-anchor" href="#_5-代码示例" aria-label="Permalink to &quot;5. 代码示例&quot;">​</a></h2><h3 id="自定义组件" tabindex="-1">自定义组件 <a class="header-anchor" href="#自定义组件" aria-label="Permalink to &quot;自定义组件&quot;">​</a></h3>',11)),l(o,{"code-base64":"Ly8gc3JjL2RlbW8vbWluZG1hcC93aWRnZXRzL21pbmRtYXAtbm9kZS9pbmRleC50c3gKZXhwb3J0IGNsYXNzIE1pbmRNYXBOb2RlIGV4dGVuZHMgU3RhdGVmdWxXaWRnZXQ8Tm9kZVByb3BzLCBOb2RlU3RhdGU+IHsKICBjb25zdHJ1Y3Rvcihwcm9wczogTm9kZVByb3BzKSB7CiAgICBzdXBlcihwcm9wcyk7CiAgICB0aGlzLnN0YXRlID0geyBob3ZlcjogZmFsc2UgfTsKICB9CgogIC8vIOW4g+WxgOWunueOsAogIGxheW91dChjb25zdHJhaW50czogQm94Q29uc3RyYWludHMpOiBTaXplIHsKICAgIC8vIOa1i+mHj+aWh+acrO+8jOiuoeeul+WuvemrmAogICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlVGV4dCh0aGlzLnByb3BzLnRpdGxlKTsKICAgIHJldHVybiB7IHdpZHRoOiB0ZXh0U2l6ZS53aWR0aCArIDIwLCBoZWlnaHQ6IDQwIH07CiAgfQoKICAvLyDnu5jliLblrp7njrAKICBwYWludChjb250ZXh0OiBCdWlsZENvbnRleHQpOiB2b2lkIHsKICAgIGNvbnN0IHsgY2FudmFzIH0gPSBjb250ZXh0OwogICAgLy8g57uY5Yi26IOM5pmvCiAgICBjYW52YXMuZHJhd1JlY3QoeyBjb2xvcjogdGhpcy5zdGF0ZS5ob3ZlciA/ICdibHVlJyA6ICdncmF5JyB9KTsKICAgIC8vIOe7mOWItuaWh+acrAogICAgY2FudmFzLmRyYXdUZXh0KHRoaXMucHJvcHMudGl0bGUsIHsgeDogMTAsIHk6IDIwIH0pOwogIH0KfQo=",lang:"typescript",meta:""})])}a(C,"_sfc_render");const A=n(I,[["render",C]]);export{Z as __pageData,A as default};
