export type SidebarItem =
  | string
  | { type: 'doc'; id: string; label?: string }
  | { type: 'category'; label: string; collapsed?: boolean; items: SidebarItem[] }
  | { type: 'autogenerated'; dirName: string }
  | { type: 'link'; label: string; href: string };

export type MarkdownFrontMatter = {
  title?: string;
  link?: string;
  date?: string;
  categories?: string[];
};

export function titleFromPath(path: string): string {
  const base = path.split('/').pop() || path;
  return base.replace(/\.(md|markdown)$/i, '');
}

export function parseMarkdownFrontMatter(content: string): {
  frontMatter: MarkdownFrontMatter;
  body: string;
} {
  const text = content.replace(/^\uFEFF/, '');
  const lines = text.split(/\r?\n/);
  if (lines[0]?.trim() !== '---') {
    return { frontMatter: {}, body: text };
  }

  let endIdx = -1;
  for (let i = 1; i < lines.length; i++) {
    if (lines[i]?.trim() === '---') {
      endIdx = i;
      break;
    }
  }
  if (endIdx === -1) {
    return { frontMatter: {}, body: text };
  }

  const frontMatter: MarkdownFrontMatter = {};
  for (let i = 1; i < endIdx; i++) {
    const line = lines[i];
    if (!line) {
      continue;
    }
    const idx = line.indexOf(':');
    if (idx === -1) {
      continue;
    }
    const key = line.slice(0, idx).trim();
    const value = line.slice(idx + 1).trim();
    if (!key) {
      continue;
    }

    if (key === 'title') {
      frontMatter.title = value.replace(/^['"]|['"]$/g, '');
      continue;
    }
    if (key === 'link') {
      frontMatter.link = value.replace(/^['"]|['"]$/g, '');
      continue;
    }
    if (key === 'date') {
      frontMatter.date = value.replace(/^['"]|['"]$/g, '');
      continue;
    }
    if (key === 'categories') {
      const normalized = value.replace(/^['"]|['"]$/g, '');
      const cleanCategory = (raw: string) => raw.trim().replace(/^['"]|['"]$/g, '');
      if (normalized.startsWith('[') && normalized.endsWith(']')) {
        const inner = normalized.slice(1, -1);
        const parts = inner.split(',').map(cleanCategory).filter(Boolean);
        frontMatter.categories = parts;
        continue;
      }
      const parts = normalized.split(',').map(cleanCategory).filter(Boolean);
      frontMatter.categories = parts.length > 0 ? parts : undefined;
      continue;
    }
  }

  const body = lines.slice(endIdx + 1).join('\n');
  return { frontMatter, body };
}

function modulePathToDocId(modulePath: string): string {
  // 将不同打包器/运行时给出的模块路径统一映射为 docId（基于 raw/ 下的相对路径，去掉扩展名）
  const normalized = modulePath.replace(/\\/g, '/');
  const marker = '/raw/';
  const idx = normalized.lastIndexOf(marker);
  const afterRaw =
    idx >= 0 ? normalized.slice(idx + marker.length) : normalized.replace(/^(\.\/|\.\.\/)+/, '');
  const cleaned = afterRaw.replace(/^raw\//, '');
  return cleaned.replace(/\.(md|markdown)$/i, '');
}

export function flattenSidebarToDocIds(
  items: SidebarItem[],
  modules: Record<string, unknown>,
): string[] {
  const out: string[] = [];

  const resolveAutogen = (dirName: string): string[] => {
    const normalized = dirName
      .replace(/\\/g, '/')
      .replace(/^\.?\//, '')
      .replace(/\/$/, '');
    const prefix = normalized ? `${normalized}/` : '';
    const ids = Object.keys(modules)
      .map(modulePathToDocId)
      .filter((id) => (prefix ? id.startsWith(prefix) : true))
      .sort((a, b) => a.localeCompare(b));
    return ids;
  };

  const walk = (list: SidebarItem[]) => {
    for (const item of list) {
      if (typeof item === 'string') {
        out.push(item);
        continue;
      }
      if (item.type === 'doc') {
        out.push(item.id);
        continue;
      }
      if (item.type === 'category') {
        walk(item.items);
        continue;
      }
      if (item.type === 'autogenerated') {
        out.push(...resolveAutogen(item.dirName));
        continue;
      }
      if (item.type === 'link') {
        continue;
      }
    }
  };

  walk(items);

  const seen = new Set<string>();
  return out.filter((id) => {
    if (seen.has(id)) {
      return false;
    }
    seen.add(id);
    return true;
  });
}

export function flattenSidebarToDocMetas(
  items: SidebarItem[],
): Array<{ id: string; title: string }> {
  const out: Array<{ id: string; title: string }> = [];

  const walk = (list: SidebarItem[]) => {
    for (const item of list) {
      if (typeof item === 'string') {
        out.push({ id: item, title: titleFromPath(item) });
        continue;
      }
      if (item.type === 'doc') {
        out.push({ id: item.id, title: item.label || titleFromPath(item.id) });
        continue;
      }
      if (item.type === 'category') {
        walk(item.items);
        continue;
      }
      if (item.type === 'autogenerated') {
        continue;
      }
      if (item.type === 'link') {
        continue;
      }
    }
  };

  walk(items);

  const seen = new Set<string>();
  return out.filter((m) => {
    if (seen.has(m.id)) {
      return false;
    }
    seen.add(m.id);
    return true;
  });
}

type MarkdownImporter = () => Promise<unknown>;

async function maybeFetchMarkdown(value: string): Promise<string> {
  // 某些构建配置会让 “?raw” 的导入结果退化为 URL 字符串，这里做一次轻量兜底：能 fetch 则拉取文本
  const trimmed = value.trimStart();
  const looksLikeMarkdown = trimmed.startsWith('#') || trimmed.includes('\n');
  if (looksLikeMarkdown) {
    return value;
  }

  const looksLikeUrl =
    /^(https?:)?\/\//.test(value) ||
    value.startsWith('/') ||
    value.startsWith('./') ||
    value.startsWith('../') ||
    /\.(md|markdown)(\?|$)/i.test(value);

  if (!looksLikeUrl || typeof fetch !== 'function') {
    return value;
  }

  try {
    const resp = await fetch(value);
    if (!resp.ok) {
      return value;
    }
    return await resp.text();
  } catch {
    return value;
  }
}

async function resolveMarkdownContent(value: unknown): Promise<string> {
  if (typeof value === 'string') {
    return await maybeFetchMarkdown(value);
  }

  if (value && typeof value === 'object' && 'default' in value) {
    const d = (value as { default?: unknown }).default;
    if (typeof d === 'string') {
      return await maybeFetchMarkdown(d);
    }
  }

  return '';
}

export function createWikiDocLoader(
  modules: Record<string, MarkdownImporter>,
): (docId: string) => Promise<{ content: string }> {
  const importerByDocId: Record<string, MarkdownImporter> = {};
  for (const [moduleKey, importer] of Object.entries(modules)) {
    importerByDocId[modulePathToDocId(moduleKey)] = importer;
  }

  return async (docId: string) => {
    const importer = importerByDocId[docId];
    if (!importer) {
      return { content: '' };
    }
    const content = await resolveMarkdownContent(await importer());
    return { content };
  };
}
