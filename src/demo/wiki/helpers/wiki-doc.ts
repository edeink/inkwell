export type SidebarItem =
  | string
  | { type: 'doc'; id: string; label?: string }
  | { type: 'category'; label: string; collapsed?: boolean; items: SidebarItem[] }
  | { type: 'autogenerated'; dirName: string }
  | { type: 'link'; label: string; href: string };

export function titleFromPath(path: string): string {
  const base = path.split('/').pop() || path;
  return base.replace(/\.(md|markdown)$/i, '');
}

function modulePathToDocId(modulePath: string): string {
  const normalized = modulePath.replace(/\\/g, '/');
  const marker = '/raw/';
  const idx = normalized.lastIndexOf(marker);
  const afterRaw =
    idx >= 0 ? normalized.slice(idx + marker.length) : normalized.replace(/^(\.\/|\.\.\/)+/, '');
  const cleaned = afterRaw.replace(/^raw\//, '');
  return cleaned.replace(/\.(md|markdown)$/i, '');
}

export function flattenSidebarToDocIds(
  items: SidebarItem[],
  modules: Record<string, unknown>,
): string[] {
  const out: string[] = [];

  const resolveAutogen = (dirName: string): string[] => {
    const normalized = dirName
      .replace(/\\/g, '/')
      .replace(/^\.?\//, '')
      .replace(/\/$/, '');
    const prefix = normalized ? `${normalized}/` : '';
    const ids = Object.keys(modules)
      .map(modulePathToDocId)
      .filter((id) => (prefix ? id.startsWith(prefix) : true))
      .sort((a, b) => a.localeCompare(b));
    return ids;
  };

  const walk = (list: SidebarItem[]) => {
    for (const item of list) {
      if (typeof item === 'string') {
        out.push(item);
        continue;
      }
      if (item.type === 'doc') {
        out.push(item.id);
        continue;
      }
      if (item.type === 'category') {
        walk(item.items);
        continue;
      }
      if (item.type === 'autogenerated') {
        out.push(...resolveAutogen(item.dirName));
        continue;
      }
      if (item.type === 'link') {
        continue;
      }
    }
  };

  walk(items);

  const seen = new Set<string>();
  return out.filter((id) => {
    if (seen.has(id)) {
      return false;
    }
    seen.add(id);
    return true;
  });
}

export function flattenSidebarToDocMetas(
  items: SidebarItem[],
): Array<{ id: string; title: string }> {
  const out: Array<{ id: string; title: string }> = [];

  const walk = (list: SidebarItem[]) => {
    for (const item of list) {
      if (typeof item === 'string') {
        out.push({ id: item, title: titleFromPath(item) });
        continue;
      }
      if (item.type === 'doc') {
        out.push({ id: item.id, title: item.label || titleFromPath(item.id) });
        continue;
      }
      if (item.type === 'category') {
        walk(item.items);
        continue;
      }
      if (item.type === 'autogenerated') {
        continue;
      }
      if (item.type === 'link') {
        continue;
      }
    }
  };

  walk(items);

  const seen = new Set<string>();
  return out.filter((m) => {
    if (seen.has(m.id)) {
      return false;
    }
    seen.add(m.id);
    return true;
  });
}

type MarkdownImporter = () => Promise<unknown>;

async function maybeFetchMarkdown(value: string): Promise<string> {
  const trimmed = value.trimStart();
  const looksLikeMarkdown = trimmed.startsWith('#') || trimmed.includes('\n');
  if (looksLikeMarkdown) {
    return value;
  }

  const looksLikeUrl =
    /^(https?:)?\/\//.test(value) ||
    value.startsWith('/') ||
    value.startsWith('./') ||
    value.startsWith('../') ||
    /\.(md|markdown)(\?|$)/i.test(value);

  if (!looksLikeUrl || typeof fetch !== 'function') {
    return value;
  }

  try {
    const resp = await fetch(value);
    if (!resp.ok) {
      return value;
    }
    return await resp.text();
  } catch {
    return value;
  }
}

async function resolveMarkdownContent(value: unknown): Promise<string> {
  if (typeof value === 'string') {
    return await maybeFetchMarkdown(value);
  }

  if (value && typeof value === 'object' && 'default' in value) {
    const d = (value as { default?: unknown }).default;
    if (typeof d === 'string') {
      return await maybeFetchMarkdown(d);
    }
  }

  return '';
}

export function createWikiDocLoader(
  modules: Record<string, MarkdownImporter>,
): (docId: string) => Promise<{ content: string }> {
  const importerByDocId: Record<string, MarkdownImporter> = {};
  for (const [moduleKey, importer] of Object.entries(modules)) {
    importerByDocId[modulePathToDocId(moduleKey)] = importer;
  }

  return async (docId: string) => {
    const importer = importerByDocId[docId];
    if (!importer) {
      return { content: '' };
    }
    const content = await resolveMarkdownContent(await importer());
    return { content };
  };
}
